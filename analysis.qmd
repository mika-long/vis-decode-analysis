---
title: "Preliminary analysis"
format:
  html: 
    code-fold: false
    reference-location: margin
    df-print: paged
    toc: true
    code-overflow: wrap
---

```{r}
#| echo: false
#| output: false

library(tidyverse)
library(ggplot2)
library(sgt)
library(numDeriv)
library(ggdist)
# setting the theme 
theme_set(theme_minimal())
```

Let us first read in the file and do some very simple pruning: 

```{r}
df <- read.csv("vis-decode-slider_all_tidy.csv") %>% as_tibble(.)

df %>% count(participantId)
```

Rows where `n < 492` are unfinished trials. After filtering those out, there should be 10 valid trials --- 1 done by Maryam, 1 done by Lily, 8 done by me. Let's pull out these ids for future filtering purposes: 

```{r}
ids <- df %>% count(participantId) %>% filter(n == 492) %>% pull(participantId) 

# make sure that og dataframe does not include data that has incomplete answers 
df <- df %>% filter(participantId %in% ids)
```

For now, let's pull out the answers related to test trials into a new dataframe --- `task_df`. 

```{r}
# create a separate dataframe for just test related trials 

task_df <- df %>% filter(grepl("task", trialId) & grepl("test", trialId) ) %>% 
    select(participantId, trialId, responseId, answer) %>% 
    mutate(answer = as.numeric(answer)) %>% 
    pivot_wider(names_from = responseId, values_from = answer, names_repair = "universal") %>% 
  separate_wider_delim(trialId, delim = "_", names = c("task", "type", "id")) %>% 
  select(-type)

task_df %>% head(5)
```

# Properties of the 5 distributions parameters 

Let us plot the distribution at different values to get a better sense of how things work. The default parameters are `mu = 0, sigma = 1, lambda = 0, p = 3, q = 10`

## Varying mean $\mu$ 

```{r}
#| code-fold: true

x_vals <- seq(-5, 5, 0.01)
mus <- c(-2, -1, 0, 1, 2)

# Create a function that generates PDF values for a specific mean
generate_pdf_data <- function(mean_val, x_values) {
  tibble(
    x = x_values,
    density = dsgt(x_values, mu = mean_val, sigma = 1, lambda = 0, p = 3, q = 10),
    mean = as.factor(mean_val)
  )
}

# Generate data for all means
plot_data <- map_dfr(mus, ~generate_pdf_data(.x, x_vals))

# Plot with ggplot2
ggplot(plot_data, aes(x = x, y = density, color = mean)) +
  geom_line() +
  labs(title = "SGT Distributions with Different Means",
       x = "x", y = "Density") +
  scale_color_brewer(palette = "RdYlBu") + 
  ylim(0, 1) + 
  xlim(-5, 5)

```

## Varying sigma $\sigma$ 

Note that $\sigma \sim \text{Uniform}[0.5, 2.5]$.

```{r}
#| code-fold: true

x_vals <- seq(-5, 5, 0.01)
sigmas <- c(0.5, 1, 1.5, 2, 2.5)

# Create a function that generates PDF values for a specific mean
generate_pdf_data <- function(sig_val, x_values) {
  tibble(
    x = x_values,
    density = dsgt(x_values, mu = 0, sigma = sig_val, lambda = 0, p = 3, q = 10),
    var = as.factor(sig_val)
  )
}

# Generate data for all means
plot_data <- map_dfr(sigmas, ~generate_pdf_data(.x, x_vals))

# Plot with ggplot2
ggplot(plot_data, aes(x = x, y = density, color = var)) +
  geom_line() +
  labs(title = "SGT Distributions with Different Variance",
       x = "x", y = "Density") +
  scale_color_brewer(palette = "RdYlBu") + 
  ylim(0, 1) + 
  xlim(-5, 5)

```

## Varying skewness $\lambda$

Note that $\lambda \sim \mathcal{N}(0, 0.33)$. 

```{r}
#| code-fold: true

x_vals <- seq(-5, 5, 0.01)
lambdas <- c(-0.66, -0.33, 0, 0.33, 0.66)

# Create a function that generates PDF values for a specific mean
generate_pdf_data <- function(lambda_vals, x_values) {
  tibble(
    x = x_values,
    density = dsgt(x_values, mu = 0, sigma = 1, lambda = lambda_vals, p = 3, q = 10),
    lambda = as.factor(lambda_vals)
  )
}

# Generate data for all means
plot_data <- map_dfr(lambdas, ~generate_pdf_data(.x, x_vals))

# Plot with ggplot2
ggplot(plot_data, aes(x = x, y = density, color = lambda)) +
  geom_line() +
  labs(title = "SGT Distributions with Different Skewness",
       x = "x", y = "Density") +
  scale_color_brewer(palette = "RdYlBu") + 
  ylim(0, 1) + 
  xlim(-5, 5)

```

## Varying $p$

Note that $p \sim \text{Uniform}[2, 4]$. 

```{r}
#| code-fold: true
#| layout-ncol: 2

x_vals <- seq(-5, 5, 0.01)
ps <- c(2, 2.5, 3, 3.5, 4)

# Create a function that generates PDF values for a specific mean
generate_pdf_data <- function(p_vals, x_values) {
  tibble(
    x = x_values,
    density = dsgt(x_values, mu = 0, sigma = 1, lambda = 0, p = p_vals, q = 10),
    p = as.factor(p_vals)
  )
}

# Generate data for all means
plot_data <- map_dfr(ps, ~generate_pdf_data(.x, x_vals))

# Plot with ggplot2
ggplot(plot_data, aes(x = x, y = density, color = p)) +
  geom_line() +
  labs(title = "SGT Distributions with Different p (lambda= 0)",
       x = "x", y = "Density") +
  scale_color_brewer(palette = "RdYlBu") + 
  ylim(0, 1) + 
  xlim(-5, 5) -> p1

# Create a function that generates PDF values for a specific mean
generate_pdf_data <- function(p_vals, x_values) {
  tibble(
    x = x_values,
    density = dsgt(x_values, mu = 0, sigma = 1, lambda = 0.3, p = p_vals, q = 10),
    p = as.factor(p_vals)
  )
}

# Generate data for all means
plot_data <- map_dfr(ps, ~generate_pdf_data(.x, x_vals))

# Plot with ggplot2
ggplot(plot_data, aes(x = x, y = density, color = p)) +
  geom_line() +
  labs(title = "SGT Distributions with Different p (lambda = 0.3)",
       x = "x", y = "Density") +
  scale_color_brewer(palette = "RdYlBu") + 
  ylim(0, 1) + 
  xlim(-5, 5) -> p2

p1 
p2
```

## Varying $q$

Note that $q \sim \text{Uniform}[1, 50]$. 

```{r}
#| code-fold: true
#| layout-ncol: 2

x_vals <- seq(-5, 5, 0.01)
qs <- c(1, 2, 10, 30, 50)

# Create a function that generates PDF values for a specific mean
generate_pdf_data <- function(q_vals, x_values) {
  tibble(
    x = x_values,
    density = dsgt(x_values, mu = 0, sigma = 1, lambda = 0, p = 3, q = q_vals),
    q = as.factor(q_vals)
  )
}

# Generate data for all means
plot_data <- map_dfr(qs, ~generate_pdf_data(.x, x_vals))

# Plot with ggplot2
ggplot(plot_data, aes(x = x, y = density, color = q)) +
  geom_line() +
  labs(title = "SGT Distributions with Different q (lambda = 0)",
       x = "x", y = "Density") +
  scale_color_brewer(palette = "RdYlBu") + 
  ylim(0, 1) + 
  xlim(-5, 5) -> p1

# Create a function that generates PDF values for a specific mean
generate_pdf_data <- function(q_vals, x_values) {
  tibble(
    x = x_values,
    density = dsgt(x_values, mu = 0, sigma = 1, lambda = 0.3, p = 3, q = q_vals),
    q = as.factor(q_vals)
  )
}

# Generate data for all means
plot_data <- map_dfr(qs, ~generate_pdf_data(.x, x_vals))

# Plot with ggplot2
ggplot(plot_data, aes(x = x, y = density, color = q)) +
  geom_line() +
  labs(title = "SGT Distributions with Different q (lambda = 0.3)",
       x = "x", y = "Density") +
  scale_color_brewer(palette = "RdYlBu") + 
  ylim(0, 1) + 
  xlim(-5, 5) -> p2

p1 
p2
```

# Functions that transform data to pixels to physical distance to visual angles 

We know that the actual svg have these properties: 

- height: 450, width: 600
- margin: top 15, right 15, bottom 40, left 50 

And here a diagram to better illustrate: 

![Diagram for how the transformations are working](mappings.png)

```{r}
# define functions
data_to_pixel_y <- function(data_y) {
  return(-395 * data_y + 410)
}

data_to_pixel_x <- function(data_x) {
  return (53.5 * data_x + 317.5)
}
```

We can verify whether the above functions actually hold by checking the transformed results with the captured pixel coordinates. The results look good so I am skipping this part. 

```{r}
#| code-fold: true 
#| output: false 

task_df %>% select(location.x, location.y, pixel.x, pixel.y) %>% 
  mutate(calculated.x = sapply(location.x, data_to_pixel_x), 
         calculated.y = sapply(location.y, data_to_pixel_y)) %>% 
  mutate(x_diff = round(pixel.x - calculated.x, 2), 
         y_diff = round(pixel.y - calculated.y, 2)) %>% 
  pull(y_diff)
```

We map from pixel coordinates to physical distances by using the `pixelsPerMM` parameter we captured during the calibration process.^[A small problem here is that during some trials, I got impatient and didn't fully do the calibration and just went with whatever default solutions I had. TLDR --- for some trials, the `pixelsPerMM` value is 3.27. For some trials, it's 3.73. To avoid confusion, I am manually creating a custom dataframe here but for future purposes, this should not be created by hand.]

Some of the `prolificId` are quite long, and that's because I was debugging an issue related to ReCAPTCHA. 

```{r}
df %>% filter(participantId %in% ids) %>% 
  filter(grepl("pixelsPerMM", responseId) | grepl("prolificId", responseId)) %>% 
  select(participantId, responseId, answer) %>% 
  pivot_wider(names_from = responseId, values_from = answer)
```

For the sake of this analysis, I am manually creating and using a custom `pixel_to_mm` data frame. 

```{r}
p <- df %>% filter(participantId %in% ids) %>% 
  filter(grepl("pixelsPerMM", responseId) | grepl("prolificId", responseId)) %>% 
  select(participantId, responseId, answer) %>% 
  pivot_wider(names_from = responseId, values_from = answer) %>% 
  pull(participantId)

# custom dataframe 
pixel_to_mm <- data.frame(participantId = p, 
  pixelToMM = c(3.73, 3.27, 3.27, 5.03, 3.73, 3.25, 3.73, 3.27, 3.73, 3.27)
)
```

Now that we know what the `pixelsPerMM` parameter is, we can write functions that transform pixel values into physical distances (measured in mm). Note that we need to do some transforms^[... specifically, distance to the x-axis would be the y-coordinate, which would be 410 - `pixel.y`. Distance to the y-axis would be the x-coordinate, which would be `pixel.x - margin.left`. ] because of the way direction works in svgs are counter-intuitive ...: 

```{r}
# define functions 
pixel_to_phy_x <- function(pixel, pxMM){
  (pixel - 50) * pxMM
}

pixel_to_phy_y <- function(pixel, pxMM){
  (410 - pixel) * pxMM
}
```

Now that we can calculate **physical distance**s, we can transform them into visual angles since we know how far the participant is sitting away from the screen (`dist_to_screen`).^[Again, from some test trials, I didn't fully do the calibration tasks, so I am again manually defining a dataframe here.] 

```{r}
# custom data frame 
vis_distance <- data.frame(participantId = p, 
                           dist_to_screen = c(426, 502, 500, 495, 485, 987, 635, 500, 479, 563))
```

We use the following equation to obtain the visual angle: 

$$\text{visual angle} = 2 \times \text{tan}^{-1}\left( \frac{\text{size}}{ 2 \times \text{distance to screen}}  \right)$$

```{r}
# corresponding function
vis_angle <- function(size, distance){
  return(2 * atan(size / (2 * distance)) * 180 / pi)
}
```

Now that these functions are ready, we are ready to perform data analysis in all possible spaces --- data space, pixel space, visual angle space. 

Following Matt's advice, let us create a single dataframe that keeps track of the all the information related to participants: 

```{r}
participants <- pixel_to_mm %>% left_join(vis_distance, by = join_by(participantId))

participants
```

---

# Task 1 --- PDF Median --- Split area into equal halves 

```{r}
# first we create separate dataframe for task 1
task1_df <- task_df %>% filter(task == "task1") %>% 
  select(-slider.x, -slider.y) %>% 
  mutate(left_area = psgt(location.x, param.mu, param.sigma, 
                        param.lambda, param.p, param.q, mean.cent = F))

task1_df %>% head(5)
```

Let's see if there's any relation between `lambda`, `p`, `q`, and `area` to the left of the selection:  

::: {.callout-caution collapse="true"}
### Weird missing data error 

There is one row that contains `NA` value, which is weird ... 

```{r}
task1_df %>% filter(if_any(everything(), is.na))

# let's try to plot this 
x_val <- seq(-5, 5, 0.01)
y_val <- dsgt(x_val, mu = -0.3, sigma = 0.8, lambda = 0, p = 2.9, q = 46.9, mean.cent=F)
data.frame(x = x_val, y = y_val) %>%
  ggplot(aes(x=x, y=y)) + 
  geom_line() +
  xlim(-5, 5) +
  ylim(0, 1)

# let's try cdf
y_val <- psgt(x_val, mu = -0.3, sigma = 0.8, lambda = 0, p = 2.9, q = 46.9, mean.cent=F)
data.frame(x = x_val, y = y_val) %>%
  ggplot(aes(x=x, y=y)) + 
  geom_line() +
  xlim(-5, 5) +
  ylim(0, 1)
```

The above all seems to be working ... Let's calculate left area separately:

```{r}
psgt(-0.3, mu = -0.3, sigma = 0.8, lambda = 0, p = 2.9, q = 46.9, mean.cent=F)
```

It is unclear why the above gives me a `NaN` answer ... Moving on ... 
:::


There seems to be some relation between `lambda` and `left_area`. Note that we are sampling $\lambda \sim \mathcal{N}(0, 0.33)$. 

```{r}
#| code-fold: true 

task1_df %>% ggplot(aes(x = param.lambda, y = left_area)) + 
  geom_point(alpha = 0.5) + 
  xlim(-1, 1) + 
  ylim(0, 1) + 
  geom_hline(yintercept = 0.5, linetype="dashed", color="gray") + 
  labs(title = "Task 1 (data space)")

task1_df %>% ggplot(aes(x = location.x, y = param.mu)) + 
  geom_point(alpha = 0.5) + 
  xlim(-1, 1) + 
  ylim(0, 1) + 
  geom_hline(yintercept = 0.5, linetype="dashed", color="gray") + 
  labs(title = "Task 1 (data space)")

task1_df %>% ggplot(aes(x = param.lambda, y = left_area)) + 
  geom_point(alpha = 0.5) + 
  xlim(-1, 1) + 
  ylim(0, 1) + 
  geom_hline(yintercept = 0.5, linetype="dashed", color="gray") + 
  facet_wrap(~participantId) + 
  labs(title = "Task 1 (data space)")
```

```{r}
#| code-fold: true

task1_df %>% ggplot(aes(x = param.p, y = left_area)) + 
  geom_point(alpha = 0.5) + 
  ylim(0, 1) + 
  geom_hline(yintercept = 0.5, linetype="dashed", color="gray") + 
  labs(title = "Task 1 (data space)")

task1_df %>% ggplot(aes(x = param.q, y = left_area)) + 
  geom_point(alpha = 0.5) + 
  ylim(0, 1) + 
  geom_hline(yintercept = 0.5, linetype="dashed", color="gray") + 
  labs(title = "Task 1 (data space)")
```

There does not seem to be any relationship between `p`, `q` and area. 

---

::: {.callout-caution}
For area, we could potentially calculate the physical space it occupies using `pixelToMM`. But what is the "visual angle" of area?? 
:::

# Task 2 --- PDF Mode --- Find highest point on the curve 

:::{.callout-note collapse="true"}
## Experimenting with `numDeriv`

```{r}
#| column: margin
#| code-fold: true

x_val <- seq(-5, 5, 0.01)
y_val <- dsgt(x_val, mu = 1.7, sigma = 1.4, lambda = -0.5, p = 3.5, q = 7.5, mean.cent=F)
data.frame(x = x_val, y = y_val) %>% 
  ggplot(aes(x = x, y = y)) +
  geom_line() +
  xlim(-5, 5) + ylim(0, 1)
```

```{r}
# Trying out numDeriv
numDeriv::grad(dsgt, 1, mu = 1.7, sigma = 1.4, lambda = -0.5, p = 3.5, q = 7.5, mean.cent=F)
atan(numDeriv::grad(dsgt, 1, mu = 1.7, sigma = 1.4, lambda = -0.5, p = 3.5, q = 7.5, mean.cent=F)) * 180 / pi
numDeriv::grad(dsgt, 0, mu = 1.7, sigma = 1.4, lambda = -0.5, p = 3.5, q = 7.5, mean.cent=F)
atan(numDeriv::grad(dsgt, 0, mu = 1.7, sigma = 1.4, lambda = -0.5, p = 3.5, q = 7.5, mean.cent=F)) * 180 / pi
numDeriv::grad(dsgt, -1, mu = 1.7, sigma = 1.4, lambda = -0.5, p = 3.5, q = 7.5, mean.cent=F)
atan(numDeriv::grad(dsgt, -1, mu = 1.7, sigma = 1.4, lambda = -0.5, p = 3.5, q = 7.5, mean.cent=F)) * 180 / pi
```

:::

First we'll create a dataframe containing only data related to task2: 

```{r}
task2_df <- task_df %>% filter(task == "task2") %>% 
  select(-slider.x, -slider.y) %>% 
  mutate(ans.x = param.mu, 
         ans.y = dsgt(param.mu, param.mu, param.sigma, param.lambda, param.p, param.q, mean.cent = FALSE),
         grad.x = numDeriv::grad(dsgt, location.x, mu = param.mu, sigma = param.sigma, 
                               lambda = param.lambda, p = param.p, q = param.q, mean.cent = FALSE))

task2_df %>% head(5)
```

First let's explore a bit: 

```{r}
#| layout-ncol: 2
#| code-fold: true 

task2_df %>% 
  ggplot(aes(x = location.x - ans.x, 
             y = location.y - ans.y)) + 
  geom_point(alpha = 0.5) + 
  labs(title = "Task 2 - Find highest point - Data")

task2_df %>% 
  ggplot(aes(x = location.x - ans.x, 
             y = grad.x)) + 
  geom_point(alpha = 0.5) + 
  labs(title = "Task 2 - Find highest point - Data")

task2_df %>% 
  ggplot(aes(x = location.x - ans.x, 
             y = atan(grad.x) * 180 / pi)) + 
  geom_point(alpha = 0.5) + 
  labs(title = "Task 2 - Find highest point - Data")
```

Hmm maybe this has something to do with `p` ...? 

```{r}
#| code-fold: true 
task2_df %>% 
  ggplot(aes(y = location.x - param.mu, x = param.p)) + 
  geom_point(alpha = 0.5)
```

```{r}
task2_df %>% 
  ggplot(aes(y = location.x - param.mu, x = param.q)) + 
  geom_point(alpha = 0.5)
```


This is the gradient at the selected point: 

```{r}
#| code-fold: true 

# from here you can see that there are some cases 
# where the difference in y is not pronounced but the difference in x is 



task2_df %>% 
  ggplot(aes(x = grad.x, y = 0)) + # gradient at the mode should be 0
  geom_point(alpha = 0.5)

task2_df %>% 
  ggplot(aes(x = grad.x)) + # gradient at the mode should be 0
  # ggdist::geom_dots() + 
  ggdist::geom_swarm(side = "top")

# looking at participant level

task2_df %>% 
  ggplot(aes(x = grad.x, y = 0)) + # gradient at the mode should be 0
  geom_point(alpha = 0.5) + 
  facet_wrap(~participantId)
```

```{r}
#| code-fold: true 

task2_df %>% 
  mutate(atan.grad.x = atan(grad.x) * 180 / pi, 
         atan.grad.ans = 0) %>% 
  ggplot(aes(x = atan.grad.x, y = atan.grad.ans)) + 
  geom_point(alpha = 0.5)
```

- For really small values (like the ones we get above) it doesn't matter whether we're looking at the gradient or the angle between the slope and the horizontal line (calculated using `atan`)

---

We can also plot the distribution of error, first for `x` and then for `y` (everything in data space): 

```{r}
#| code-fold: true

task2_df %>% 
  mutate(answer.x = param.mu, 
         answer.y = dsgt(x=param.mu, mu = param.mu, sigma=param.sigma, 
                         lambda=param.lambda, p=param.p, q=param.q, mean.cent = F)) %>% 
  mutate(x_diff = location.x - answer.x) %>% 
  ggplot(aes(x = x_diff)) + 
  # ggdist::geom_dots() + 
  ggdist::geom_swarm(side = "top") + 
  labs(title= "Task 2 (data space)")

task2_df %>% 
  mutate(answer.x = param.mu, 
         answer.y = dsgt(x=param.mu, mu = param.mu, sigma=param.sigma, 
                         lambda=param.lambda, p=param.p, q=param.q, mean.cent = F)) %>% 
  mutate(y_diff = location.y - answer.y) %>% 
  ggplot(aes(x = y_diff)) + 
  # ggdist::geom_dots() + 
  ggdist::geom_swarm(side = "top") + 
  labs(title= "Task 2 (data space)")
```

What about distribution of error in gradient space?

```{r}
#| code-fold: true 
task2_df %>% 
  mutate(grad.x = numDeriv::grad(dsgt, location.x, mu = param.mu, sigma = param.sigma, 
                                 lambda = param.lambda, p = param.p, q = param.q, mean.cent=F), 
         grad.ans = 0,
         ) %>%
  mutate(diff = grad.ans - grad.x) %>% 
  ggplot(aes(x = diff)) + 
  # ggdist::geom_dots() + 
  # ggdist::geom_weave(side = "top") + 
  ggdist::geom_swarm(side = "top") 

task2_df %>% 
  mutate(grad.x = numDeriv::grad(dsgt, location.x, mu = param.mu, sigma = param.sigma, 
                                 lambda = param.lambda, p = param.p, q = param.q, mean.cent=F), 
         grad.ans = 0,
         ) %>%
  mutate(diff = grad.ans - grad.x) %>% 
  ggplot(aes(x = diff)) + 
  # ggdist::geom_dots() + 
  # ggdist::geom_weave(side = "top") + 
  ggdist::geom_swarm(side = "top") + 
  facet_wrap(~participantId)
```

# Task 3 --- CDF Median --- find point where `y == 0.5`

First create the data frame for task 3:

```{r}
task3_df <- task_df %>% filter(task == "task3") %>% 
  select(-slider.x, -slider.y) 

task3_df %>%  head(5)
```

```{r}
#| code-fold: true
#| layout-ncol: 2

# data space 
task3_df %>% 
  ggplot(aes(x = location.x, y = location.y - 0.5)) + 
  geom_point() + 
  geom_hline(yintercept = 0, linetype="dashed", color="gray") + 
  labs(title="Task 3 -- CDF Median")

# physical space
task3_df %>% left_join(participants, by = join_by(participantId)) %>% 
  mutate(phy.x = pixel_to_phy_x(pixel.x, pixelToMM), 
         phy.y = pixel_to_phy_y(pixel.y, pixelToMM), 
         ans.y = pixel_to_phy_y(data_to_pixel_y(0.5), pixelToMM)) %>% 
  ggplot(aes(x = phy.x, y = phy.y - ans.y)) + 
  geom_point() + 
  geom_hline(yintercept = 0, linetype="dashed", color="gray") + 
  labs(title="Task 3 -- CDF Median") 

# visual angle
task3_df %>% left_join(participants, by = join_by(participantId)) %>% 
  mutate(phy.x = pixel_to_phy_x(pixel.x, pixelToMM), 
         phy.y = pixel_to_phy_y(pixel.y, pixelToMM), 
         ans.y = pixel_to_phy_y(data_to_pixel_y(0.5), pixelToMM), 
         va.ans.y = vis_angle(ans.y, dist_to_screen), 
         va.phy.y = vis_angle(phy.y, dist_to_screen), 
         va.phy.x = vis_angle(phy.x, dist_to_screen)) %>% 
  ggplot(aes(x = va.phy.x, y = va.phy.y - va.ans.y)) + 
  geom_point() + 
  geom_hline(yintercept = 0, linetype="dashed", color="gray") + 
  labs(title="Task 3 -- CDF Median") 

task3_df %>% left_join(participants, by = join_by(participantId)) %>% 
  mutate(phy.x = pixel_to_phy_x(pixel.x, pixelToMM), 
         phy.y = pixel_to_phy_y(pixel.y, pixelToMM), 
         ans.y = pixel_to_phy_y(data_to_pixel_y(0.5), pixelToMM), 
         va.ans.y = vis_angle(ans.y, dist_to_screen), 
         va.phy.y = vis_angle(phy.y, dist_to_screen), 
         va.phy.x = vis_angle(phy.x, dist_to_screen)) %>% 
  ggplot(aes(x = va.phy.x, y = va.phy.y - va.ans.y)) + 
  geom_point() + 
  geom_hline(yintercept = 0, linetype="dashed", color="gray") + 
  labs(title="Task 3 -- CDF Median") + 
  facet_wrap(~participantId)
```

# Task 4 --- CDF Mode --- Find slope

Recall that mode is just `param.mu` based on our definition. However, it is unclear how slope in the data sense transforms to slope in the physical / visual angle sense. But let's just get the data for task 4 first: 

```{r}
task4_df <- task_df %>% filter(task == "task4") %>% 
  select(-slider.x, -slider.y) %>% 
  mutate(slope = dsgt(location.x, param.mu, param.sigma, param.lambda, param.p, param.q, mean.cent=FALSE), 
         ans = dsgt(param.mu, param.mu, param.sigma, param.lambda, param.p, param.q, mean.cent=FALSE))

task4_df %>% head(5)
```

There is some outlier in the data^[Maryam was interpreting slope to mean something else.], so we filter that out. Ther also doesn't seem to be any relations between slope and how far the dot is. 

```{r}
task4_df <- task4_df %>% filter(participantId != "5f37a06e-50e4-4489-948f-c4f25bd38d17")
```


```{r}
#| code-fold: true
#| layout-ncol: 2

# let's see what this looks like 
task4_df %>% 
  ggplot(aes(x = location.x, y = slope - ans)) + 
  geom_point(alpha = 0.5) + 
  labs(title = "Task 4 -- Find Max Slope -- Data")

task4_df %>% 
  ggplot(aes(x = slope - ans)) + 
  ggdist::geom_dots() + 
  labs(title = "Task 4 -- Find Max Slope -- Data")

task4_df %>% 
  ggplot(aes(x = slope - ans)) + 
  ggdist::geom_dots() + 
  labs(title = "Task 4 -- Find Max Slope -- Data") + 
  facet_wrap(~participantId)
```

:::{.callout-caution}
What does slope translate into, in the physical distance / visual angle sense?
:::



If we were to plot the value of the selected `x` and the actual mode of the distribution, we get something that gives more variation: 

```{r}
#| code-fold: true
task4_df %>% 
  ggplot(aes(x = location.x, y = param.mu)) + 
  geom_point(alpha=0.8) + 
  geom_abline(slope = 1, intercept = 0, linetype="dashed", color="gray") + 
  coord_equal()
```

# Task 5 --- Project from dot to axes

First we get the data frame for task 5: 

```{r}
task5_df <- task_df %>% filter(task == "task5") %>% 
  select(participantId, task, id, location.x, location.y, slider.x, slider.y)

task5_df %>% head(5)
```

### How accurate were the `x`s? 

```{r}
#| code-fold: true

task5_df %>% 
  ggplot(aes(y = slider.x - location.x, x = location.y)) + 
  geom_point(alpha=0.5) + 
  geom_hline(yintercept = 0, color="gray", linetype="dashed") + 
  labs(title="Task 5 - Project from Dot to X-Axes - Data")

task5_df %>% left_join(participants, by = join_by(participantId)) %>% 
  mutate(phy.x = pixel_to_phy_x(data_to_pixel_x(slider.x), pixelToMM), 
         ans.phy.x = pixel_to_phy_x(data_to_pixel_x(location.x), pixelToMM),
         ans.phy.y = pixel_to_phy_y(data_to_pixel_y(location.y), pixelToMM)) %>%
  ggplot(aes(x = ans.phy.y, y = phy.x - ans.phy.x)) + 
  geom_point(alpha = 0.5) +
  geom_hline(yintercept = 0, linetype="dashed", color="gray") + 
  labs(title="Task 5 - Project from Dot to X-Axes - Screen")

task5_df %>% left_join(participants, by = join_by(participantId)) %>% 
  mutate(phy.x = pixel_to_phy_x(data_to_pixel_x(slider.x), pixelToMM), 
         ans.phy.x = pixel_to_phy_x(data_to_pixel_x(location.x), pixelToMM),
         ans.phy.y = pixel_to_phy_y(data_to_pixel_y(location.y), pixelToMM),
         va.x = vis_angle(phy.x, dist_to_screen), 
         ans.va.x = vis_angle(ans.phy.x, dist_to_screen), 
         ans.va.y = vis_angle(ans.phy.y, dist_to_screen)) %>%
  ggplot(aes(x = ans.va.y, y = va.x - ans.va.x)) + 
  geom_point(alpha = 0.5) +
  geom_hline(yintercept = 0, linetype="dashed", color="gray") + 
  labs(title="Task 5 - Project from Dot to X-Axes - Vis Angle")

task5_df %>% left_join(participants, by = join_by(participantId)) %>% 
  mutate(phy.x = pixel_to_phy_x(data_to_pixel_x(slider.x), pixelToMM), 
         ans.phy.x = pixel_to_phy_x(data_to_pixel_x(location.x), pixelToMM),
         ans.phy.y = pixel_to_phy_y(data_to_pixel_y(location.y), pixelToMM),
         va.x = vis_angle(phy.x, dist_to_screen), 
         ans.va.x = vis_angle(ans.phy.x, dist_to_screen), 
         ans.va.y = vis_angle(ans.phy.y, dist_to_screen)) %>%
  ggplot(aes(x = ans.va.y, y = va.x - ans.va.x)) + 
  geom_point(alpha = 0.5) +
  geom_hline(yintercept = 0, linetype="dashed", color="gray") +
  facet_wrap(~participantId) + 
  labs(title="Task 5 - Project from Dot to X-Axes - Vis Angle")
```

### How accurate were the `y`s? 

```{r}
#| code-fold: true 

task5_df %>% 
  ggplot(aes(x = location.x, y = slider.y - location.y)) + 
  geom_point(alpha=0.5) + 
  geom_hline(yintercept = 0, linetype="dashed", color="gray") + 
  labs(title="Task 5 - Project from dot to Y-Axes - Data")

task5_df %>% left_join(participants, by = join_by(participantId)) %>% 
  mutate(phy.y = pixel_to_phy_y(data_to_pixel_y(slider.y), pixelToMM), 
         ans.phy.y = pixel_to_phy_y(data_to_pixel_y(location.y), pixelToMM), 
         ans.phy.x = pixel_to_phy_x(data_to_pixel_x(location.x), pixelToMM)) %>%
  ggplot(aes(x = ans.phy.x, y = phy.y - ans.phy.y)) + 
  geom_point(alpha = 0.5) + 
  geom_hline(yintercept = 0, linetype="dashed", color="gray") + 
  labs(title = "Task 5 - Project from dot to Y-Axes - Screen")

task5_df %>% left_join(participants, by = join_by(participantId)) %>% 
  mutate(phy.y = pixel_to_phy_y(data_to_pixel_y(slider.y), pixelToMM), 
         ans.phy.y = pixel_to_phy_y(data_to_pixel_y(location.y), pixelToMM), 
         va.y = vis_angle(phy.y, dist_to_screen), 
         ans.va.y = vis_angle(ans.phy.y, dist_to_screen), 
         ans.phy.x = pixel_to_phy_x(data_to_pixel_x(location.x), pixelToMM),
         ans.va.x = vis_angle(ans.phy.x, dist_to_screen)) %>%
  ggplot(aes(x = ans.va.x, y = va.y - ans.va.y)) + 
  geom_point(alpha = 0.5) + 
  geom_hline(yintercept = 0, linetype="dashed", color="gray") + 
  labs(title = "Task 5 - Project from dot to Y-Axes - Visual Angle")

task5_df %>% left_join(participants, by = join_by(participantId)) %>% 
  mutate(phy.y = pixel_to_phy_y(data_to_pixel_y(slider.y), pixelToMM), 
         ans.phy.y = pixel_to_phy_y(data_to_pixel_y(location.y), pixelToMM), 
         va.y = vis_angle(phy.y, dist_to_screen), 
         ans.va.y = vis_angle(ans.phy.y, dist_to_screen), 
         ans.phy.x = pixel_to_phy_x(data_to_pixel_x(location.x), pixelToMM),
         ans.va.x = vis_angle(ans.phy.x, dist_to_screen)) %>%
  ggplot(aes(x = ans.va.x, y = va.y - ans.va.y)) + 
  geom_point(alpha = 0.5) + 
  geom_hline(yintercept = 0, linetype="dashed", color="gray") + 
  labs(title = "Task 5 - Project from dot to Y-Axes - Visual Angle") + 
  facet_wrap(~participantId)
```

