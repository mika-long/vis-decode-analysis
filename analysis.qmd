---
title: "analysis"
format:
  html: 
    code-fold: true
---

```{r}
#| echo: false
#| output: false

library(tidyverse)
library(ggplot2)
library(sgt)
library(numDeriv)
```

Let first read in the file. 

```{r}
df <- read.csv("vis-decode-slider_all_tidy.csv") %>% as_tibble(.)
```

Let us just do some very simple pruning through the data: 

```{r}
df %>% count(participantId)
```

Though where `n < 492` are those that didn't finish the full set of things. Right now we have 10 trials --- 1 done by Maryam, 1 done by Lily, 8 done by me. Those done by Maryam and Lily had some issue with the tangent line (the guideline didn't show up correctly) but they did their best for interpretation. Let's pull out these ids

```{r}
df %>% count(participantId) %>% filter(n == 492) %>% pull(participantId) -> ids
ids
```

```{r}
df %>% filter(participantId %in% ids) %>% 
    filter(grepl("task", trialId) & grepl("test", trialId) ) %>% 
    select(participantId, trialId, responseId, answer) %>% 
    mutate(answer = as.numeric(answer)) %>% 
    pivot_wider(names_from = responseId, values_from = answer, names_repair = "universal") -> task_df # %>% 
    # separate_wider_delim(trialId, delim="_", names = c("TaskType", "type", "id")) %>% 
    # select(-type, -pixel.x, -pixel.y) -> task_df

task_df
```

# Functions that transform data to pixels

We know that the actual svg have these properties: 

- height: 450, width: 600
- margin: top 15, right 15, bottom 40, left 50 

```{r}
convert_to_pixel_y <- function(data_y) {
  return(-395 * data_y + 410)
}

convert_to_pixel_x <- function(data_x) {
  return (53.5 * data_x + 317.5)
}
```

Let's see if this actually hold: 

```{r}
task_df %>% select(location.x, location.y, pixel.x, pixel.y) %>% 
  mutate(calculated.x = sapply(location.x, convert_to_pixel_x), 
         calculated.y = sapply(location.y, convert_to_pixel_y)) %>% 
  mutate(x_diff = round(pixel.x - calculated.x, 2), 
         y_diff = round(pixel.y - calculated.y, 2)) %>% 
  pull(y_diff)
```

This looks pretty good so I'm going to take these numbers. 

## Visual Angle and physical distance 

Here's a diagram that I created: 

![figures](mappings.png)

```{r}
df %>% filter(grepl("pixelsPerMM", responseId) | grepl("prolificId", responseId)) %>% 
  select(participantId, responseId, answer) %>% 
  pivot_wider(names_from = responseId, values_from = answer) # %>% 
  # select(-participantId) # %>% view(.)
```

Ok basically --- if it is `sheng test 1` to `sheng test 4` then all of these are tested on the screen at school. Otherwise, the ones tested by Sheng is at home. Otherwise, it's tested by Maryam and others. 

If it's tested at the screen at school, then `pixelsPerMM` is about 3.27. If it's tested at home, then it's about 3.73. Lily's is 3.25. Maryam's is 5.13. Let's just create our own custom dataframe: 

```{r}
pixel_to_mm <- data.frame(participantId = c(
  "0c671e0c-0be6-4ae5-a78e-638e59d43ddd", 
  "1a39e480-57b1-4bb6-ad31-cf90236fb047", 
  "51da084f-6438-4f40-9569-443698b4437e", 
  "5f37a06e-50e4-4489-948f-c4f25bd38d17", 
  "7856a1bc-7bae-436a-a91f-a94e3d3f5683", 	
  "85349f2b-c75a-46ff-8f80-fafc92da11a7",	
  "9f6c940d-bb71-406e-872e-2873b533048f", 
  "c87f9143-d9e8-4f50-afca-03a0839951fb",
  "dc2d1f07-3b58-4484-a4b1-3f8308154717"
), 
  pixelToMM = c(3.74, 3.27, 3.27, 5.03, 3.73, 3.25, 3.73, 3.27, 2.73)
)
```

Distance to the x-axis would be the y-coordinate, which would be 410 - `pixel.y`. Distance to the y-axis would be the x-coordinate, which would be `pixel.x - margin.left`. 

Let's use Task 2 as an example. 

```{r}
#| code-fold: false 
task_df %>% filter(grepl("task2", trialId)) %>% 
  select(participantId, pixel.y, pixel.x) %>% 
  left_join(pixel_to_mm, by = join_by(participantId)) %>% 
  mutate(phy.y = (410 - pixel.y) * pixelToMM / 100, 
         phy.x = (pixel.x - 50) * pixelToMM / 100 )
```

# Task 1 --- PDF Median --- split area into equal halves 

```{r}
task_df %>% filter(grepl("task1", trialId)) %>% 
  mutate(left_area = psgt(location.x, param.mu, param.sigma, 
                          param.lambda, param.p, param.q, mean.cent = F)) %>% 
  select(-trialId, -slider.x, -slider.y) %>% 
  head(5)
```

Let's see if there's any relation between `lambda`, `p`, `q`, and `area` to the left of the selection:  

```{r}
#| layout-ncol: 3

task_df %>% filter(grepl("task1", trialId)) %>% 
  mutate(left_area = psgt(location.x, param.mu, param.sigma, 
                          param.lambda, param.p, param.q, mean.cent=F)) %>% 
  select(param.lambda, left_area) %>% 
  ggplot(aes(x = param.lambda, y = left_area)) + 
  geom_point(alpha = 0.5) + 
  theme_minimal() + xlim(-1, 1) + ylim(0, 1) + 
  geom_hline(yintercept = 0.5, linetype="dashed", color="gray")

task_df %>% filter(grepl("task1", trialId)) %>% 
  mutate(left_area = psgt(location.x, param.mu, param.sigma, 
                          param.lambda, param.p, param.q, mean.cent=F)) %>% 
  select(param.p, left_area) %>% 
  ggplot(aes(x = param.p, y = left_area)) + 
  geom_point(alpha = 0.5) + 
  theme_minimal() +
  ylim(0, 1) + 
  geom_hline(yintercept = 0.5, linetype="dashed", color="gray")

task_df %>% filter(grepl("task1", trialId)) %>% 
  mutate(left_area = psgt(location.x, param.mu, param.sigma, 
                          param.lambda, param.p, param.q, mean.cent=F)) %>% 
  select(param.q, left_area) %>% 
  ggplot(aes(x = param.q, y = left_area)) + 
  geom_point(alpha = 0.5) + 
  theme_minimal() +
  ylim(0, 1) + 
  geom_hline(yintercept = 0.5, linetype="dashed", color="gray")
```

Other than `lambda`, we don't see any trends with `p` or `q`. This makes sense, as `lambda` explicitly controls the skewness. 

## Task 2 --- PDF Mode --- Find highest point on the curve 

TODO --- this is where we use `numDeriv` !!! 

```{r}
task_df %>% filter(grepl("task2", trialId)) %>%
  mutate(answer.x = param.mu, 
         answer.y = dsgt(x=param.mu, mu = param.mu, sigma=param.sigma, 
                         lambda=param.lambda, p=param.p, q=param.q, mean.cent = F)) %>% 
  select(participantId, location.x, location.y, answer.x, answer.y) %>% 
  head(5)
```

Let's try to plot the distribution of error, first for `x` and then for `y`: 

```{r}
#| layout-ncol: 2

task_df %>% filter(grepl("task2", trialId)) %>%
  mutate(answer.x = param.mu, 
         answer.y = dsgt(x=param.mu, mu = param.mu, sigma=param.sigma, 
                         lambda=param.lambda, p=param.p, q=param.q, mean.cent = F)) %>% 
  select(participantId, location.x, location.y, answer.x, answer.y) %>% 
  mutate(x_diff = location.x - answer.x) %>% 
  ggplot(aes(x = x_diff)) + geom_density() + theme_minimal()

task_df %>% filter(grepl("task2", trialId)) %>%
  mutate(answer.x = param.mu, 
         answer.y = dsgt(x=param.mu, mu = param.mu, sigma=param.sigma, 
                         lambda=param.lambda, p=param.p, q=param.q, mean.cent = F)) %>% 
  select(participantId, location.x, location.y, answer.x, answer.y) %>% 
  mutate(y_diff = location.y - answer.y) %>% 
  ggplot(aes(x = y_diff)) + geom_density() + theme_minimal()
```

TODO: `numderiv` and angle calculations ... 

## Task 3 --- CDF Median --- find point where `y == 0.5`

First look at the data: 

```{r}
task_df %>% filter(grepl("task3", trialId)) %>% 
  select(-trialId) %>% 
  head(5)
```

Let's plot: 

```{r}
task_df %>% filter(grepl("task3", trialId)) %>% 
  ggplot(aes(x = location.x, y = location.y)) + 
  geom_point() + 
  theme_minimal() + 
  geom_hline(yintercept = 0.5, linetype="dashed", color="gray") 
```

And if this is by participant: 

```{r}
task_df %>% filter(grepl("task3", trialId)) %>% 
  ggplot(aes(x = location.x, y = location.y)) + 
  geom_point() + 
  theme_minimal() + 
  geom_hline(yintercept = 0.5, linetype="dashed", color="gray") + 
  facet_wrap(~ participantId)
```

What about distribution of error? 

```{r}
task_df %>% filter(grepl("task3", trialId)) %>% 
  mutate(y_diff = 0.5 - location.y) %>% 
  ggplot(aes(x = y_diff)) + 
  geom_density() + 
  theme_minimal()
```

## Task 4 --- CDF Mode --- Find slope

Recall that mode is just `param.mu`. 

```{r}
task_df %>% filter(grepl("task3", trialId)) %>% 
  ggplot(aes(x = location.x, y = param.mu)) + 
  geom_point(alpha=0.5) + theme_minimal() + 
  geom_abline(slope = 1, intercept = 0, linetype="dashed", color="gray") + 
  coord_equal()
```


## Task 5 --- Project from dot to axes

```{r}
df %>% filter(grepl("task5", trialId)) %>% 
  filter(grepl("test", trialId)) %>%
  select(participantId, trialId, responseId, answer) %>% 
  mutate(answer = as.numeric(answer)) %>% 
  pivot_wider(names_from = responseId, values_from = answer, names_repair = "universal") %>% 
  separate_wider_delim(trialId, delim="_", names = c("TaskType", "type", "id")) %>% 
  select(-type) -> task_5

task_5 %>% head(5)
```

How accurate where the xs? 

```{r}
task_5 %>% 
  ggplot(aes(x = slider.x, y = location.x)) + 
  geom_point(alpha=0.5) + 
  theme_minimal() + 
  geom_abline(intercept = 0, slope = 1, color = "gray", linetype = "dashed") + 
  coord_equal()
```

How accurate where the ys? 

```{r}
task_5 %>% 
  ggplot(aes(x = slider.y, y = location.y)) + 
  geom_point(alpha=0.5) + 
  theme_minimal() + 
  geom_abline(intercept = 0, slope = 1, color = "gray", linetype = "dashed") + 
  coord_equal()
```

We can also try to plot things in data space: 

```{r}
# TODO 
```

