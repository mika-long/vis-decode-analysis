---
title: "Preliminary analysis"
format:
  html: 
    code-fold: false
---

```{r}
#| echo: false
#| output: false

library(tidyverse)
library(ggplot2)
library(sgt)
library(numDeriv)
```

Let us first read in the file and do some very simple pruning: 

```{r}
df <- read.csv("vis-decode-slider_all_tidy.csv") %>% as_tibble(.)

df %>% count(participantId)
```

For rows where `n < 492` are those that didn't finish the full set of things. Right now we have 10 trials --- 1 done by Maryam, 1 done by Lily, 8 done by me. Those done by Maryam and Lily had some issue with the tangent line (the guideline didn't show up correctly) but they did their best for interpretation. Let's pull out these ids

```{r}
df %>% count(participantId) %>% filter(n == 492) %>% pull(participantId) -> ids

ids
```

```{r}
# create a separate dataframe for just test related trials 

task_df <- df %>% filter(participantId %in% ids) %>% 
    filter(grepl("task", trialId) & grepl("test", trialId) ) %>% 
    select(participantId, trialId, responseId, answer) %>% 
    mutate(answer = as.numeric(answer)) %>% 
    pivot_wider(names_from = responseId, values_from = answer, names_repair = "universal")

task_df %>% head(5)
```

# Functions that transform data to pixels

We know that the actual svg have these properties: 

- height: 450, width: 600
- margin: top 15, right 15, bottom 40, left 50 

```{r}
convert_to_pixel_y <- function(data_y) {
  return(-395 * data_y + 410)
}

convert_to_pixel_x <- function(data_x) {
  return (53.5 * data_x + 317.5)
}
```

Let's see if this actually hold: 

```{r}
task_df %>% select(location.x, location.y, pixel.x, pixel.y) %>% 
  mutate(calculated.x = sapply(location.x, convert_to_pixel_x), 
         calculated.y = sapply(location.y, convert_to_pixel_y)) %>% 
  mutate(x_diff = round(pixel.x - calculated.x, 2), 
         y_diff = round(pixel.y - calculated.y, 2)) %>% 
  pull(y_diff)
```

This looks pretty good so I'm going to take these numbers. 

## Visual Angle and physical distance 

Here's a diagram that I created: 

![figures](mappings.png)

```{r}
df %>% filter(participantId %in% ids) %>% 
  filter(grepl("pixelsPerMM", responseId) | grepl("prolificId", responseId)) %>% 
  select(participantId, responseId, answer) %>% 
  pivot_wider(names_from = responseId, values_from = answer) # %>% 
  # select(-participantId) # %>% view(.)
```

Ok basically --- if it is `sheng test 1` to `sheng test 4` then all of these are tested on the screen at school. Otherwise, the ones tested by Sheng is at home. Otherwise, it's tested by Maryam and others. 

If it's tested at the screen at school, then `pixelsPerMM` is about 3.27. If it's tested at home, then it's about 3.73. Lily's is 3.25. Maryam's is 5.13. Let's just create our own custom dataframe: 

```{r}
p <- df %>% filter(participantId %in% ids) %>% 
  filter(grepl("pixelsPerMM", responseId) | grepl("prolificId", responseId)) %>% 
  select(participantId, responseId, answer) %>% 
  pivot_wider(names_from = responseId, values_from = answer) %>% 
  pull(participantId)

pixel_to_mm <- data.frame(participantId = p, 
  pixelToMM = c(3.73, 3.27, 3.27, 5.03, 3.73, 3.25, 3.73, 3.27, 3.73, 3.27)
)
```

Distance to the x-axis would be the y-coordinate, which would be 410 - `pixel.y`. Distance to the y-axis would be the x-coordinate, which would be `pixel.x - margin.left`. 

Let's use Task 2 as an example. 

```{r}
#| code-fold: false 

task_df %>% filter(grepl("task2", trialId)) %>% 
  select(participantId, pixel.y, pixel.x) %>% 
  left_join(pixel_to_mm, by = join_by(participantId)) %>% 
  mutate(phy.y = (410 - pixel.y) * pixelToMM / 100, 
         phy.x = (pixel.x - 50) * pixelToMM / 100 )
```

## From physical distance to visual angle 

```{r}
df %>% filter(grepl("dist", responseId) & grepl("MM", responseId)) %>% 
  select(participantId, answer) %>% 
  left_join(df)
```

There are scenarios where I didn't fully do the test so the answer is something like ~ 200 mm ... Let's for now change them to something closesr to 400 ... 

```{r}
vis_distance <- data.frame(participantId = p, 
                           dist_to_screen = c(426, 502, 500, 495, 485, 987, 635, 500, 479, 563))
```

We are going to use the following function to calculate visual angle: 

$$\text{visual angle} = 2 \times \text{tan}^{-1}\left( \frac{\text{size} / 2}{ \text{distance}}  \right)$$

```{r}
vis_angle <- function(size, distance){
  return(2 * atan(size / (2 * distance)))
}

convert_to_physical_x <- function(pixel_x, pixelToMM){
  return( (pixel_x - 50) * pixelToMM )
}
convert_to_physical_y <- function(pixel_y, pixelToMM){
  return((410 - pixel_y) * pixelToMM)
}
```

```{r}
task_df %>% filter(grepl("task2", trialId)) %>% 
  select(participantId, pixel.y, pixel.x) %>% 
  left_join(pixel_to_mm, by = join_by(participantId)) %>% 
  mutate(phy.y = convert_to_physical_y(pixel.y, pixelToMM), 
         phy.x = convert_to_physical_x(pixel.x, pixelToMM)) %>% 
  left_join(vis_distance, by = join_by(participantId)) %>% 
  mutate(va.x = vis_angle(phy.x, dist_to_screen), 
         va.y = vis_angle(phy.y, dist_to_screen))
```

---

# Task 1 --- PDF Median --- split area into equal halves 

```{r}
task_df %>% filter(grepl("task1", trialId)) %>% 
  mutate(left_area = psgt(location.x, param.mu, param.sigma, 
                          param.lambda, param.p, param.q, mean.cent = F)) %>% 
  select(-trialId, -slider.x, -slider.y) %>% 
  head(5)
```

Let's see if there's any relation between `lambda`, `p`, `q`, and `area` to the left of the selection:  

```{r}
#| layout-ncol: 3

task_df %>% filter(grepl("task1", trialId)) %>% 
  mutate(left_area = psgt(location.x, param.mu, param.sigma, 
                          param.lambda, param.p, param.q, mean.cent=F)) %>% 
  select(param.lambda, left_area) %>% 
  ggplot(aes(x = param.lambda, y = left_area)) + 
  geom_point(alpha = 0.5) + 
  theme_minimal() + xlim(-1, 1) + ylim(0, 1) + 
  geom_hline(yintercept = 0.5, linetype="dashed", color="gray")

task_df %>% filter(grepl("task1", trialId)) %>% 
  mutate(left_area = psgt(location.x, param.mu, param.sigma, 
                          param.lambda, param.p, param.q, mean.cent=F)) %>% 
  select(param.p, left_area) %>% 
  ggplot(aes(x = param.p, y = left_area)) + 
  geom_point(alpha = 0.5) + 
  theme_minimal() +
  ylim(0, 1) + 
  geom_hline(yintercept = 0.5, linetype="dashed", color="gray")

task_df %>% filter(grepl("task1", trialId)) %>% 
  mutate(left_area = psgt(location.x, param.mu, param.sigma, 
                          param.lambda, param.p, param.q, mean.cent=F)) %>% 
  select(param.q, left_area) %>% 
  ggplot(aes(x = param.q, y = left_area)) + 
  geom_point(alpha = 0.5) + 
  theme_minimal() +
  ylim(0, 1) + 
  geom_hline(yintercept = 0.5, linetype="dashed", color="gray")
```

Other than `lambda`, we don't see any trends with `p` or `q`. This makes sense, as `lambda` explicitly controls the skewness. 

TODO --- write a math model for this ... that also takes into account of the visual distance ...? 

## Task 2 --- PDF Mode --- Find highest point on the curve 

```{r}
task_df %>% filter(grepl("task2", trialId)) %>%
  mutate(answer.x = param.mu, 
         answer.y = dsgt(x=param.mu, mu = param.mu, sigma=param.sigma, 
                         lambda=param.lambda, p=param.p, q=param.q, mean.cent = F)) %>% 
  select(participantId, location.x, location.y, answer.x, answer.y) %>% 
  left_join(pixel_to_mm, by = join_by(participantId)) %>% 
  mutate(location.px.x = convert_to_pixel_x(location.x), 
         location.px.y = convert_to_pixel_y(location.y), 
         answer.px.x = convert_to_pixel_x(answer.x), 
         answer.px.y = convert_to_pixel_y(answer.y), 
         location.phy.x = convert_to_physical_x(answer.px.x, pixelToMM),
         location.phy.y = convert_to_physical_y(answer.px.y, pixelToMM),
         ) %>% 
  left_join(vis_distance, by = join_by(participantId)) %>% 
  mutate(location.va.x = vis_angle(location.phy.x, dist_to_screen),
         location.va.y = vis_angle(location.phy.y, dist_to_screen)) %>% 
  head(5)
```

Let's try to plot the distribution of error, first for `x` and then for `y`: 

```{r}
#| layout-ncol: 2

task_df %>% filter(grepl("task2", trialId)) %>%
  mutate(answer.x = param.mu, 
         answer.y = dsgt(x=param.mu, mu = param.mu, sigma=param.sigma, 
                         lambda=param.lambda, p=param.p, q=param.q, mean.cent = F)) %>% 
  select(participantId, location.x, location.y, answer.x, answer.y) %>% 
  mutate(x_diff = location.x - answer.x) %>% 
  ggplot(aes(x = x_diff)) + geom_density() + theme_minimal()

task_df %>% filter(grepl("task2", trialId)) %>%
  mutate(answer.x = param.mu, 
         answer.y = dsgt(x=param.mu, mu = param.mu, sigma=param.sigma, 
                         lambda=param.lambda, p=param.p, q=param.q, mean.cent = F)) %>% 
  select(participantId, location.x, location.y, answer.x, answer.y) %>% 
  mutate(y_diff = location.y - answer.y) %>% 
  ggplot(aes(x = y_diff)) + geom_density() + theme_minimal()
```

TODO: `numderiv` and angle calculations ... 

## Task 3 --- CDF Median --- find point where `y == 0.5`

First look at the data: 

```{r}
task_df %>% filter(grepl("task3", trialId)) %>% 
  select(-trialId) %>% 
  head(5)
```

Let's plot: 

```{r}
task_df %>% filter(grepl("task3", trialId)) %>% 
  ggplot(aes(x = location.x, y = location.y)) + 
  geom_point() + 
  theme_minimal() + 
  geom_hline(yintercept = 0.5, linetype="dashed", color="gray") 
```

And if this is by participant: 

```{r}
task_df %>% filter(grepl("task3", trialId)) %>% 
  ggplot(aes(x = location.x, y = location.y)) + 
  geom_point() + 
  theme_minimal() + 
  geom_hline(yintercept = 0.5, linetype="dashed", color="gray") + 
  facet_wrap(~ participantId)
```

What about distribution of error? 

```{r}
task_df %>% filter(grepl("task3", trialId)) %>% 
  mutate(y_diff = 0.5 - location.y) %>% 
  ggplot(aes(x = y_diff)) + 
  geom_density() + 
  theme_minimal()
```

---

Let's do things in the physical distance as well as visual angle sense: 

```{r}
d <- task_df %>% filter(grepl("task3", trialId)) %>% 
  left_join(pixel_to_mm, by = join_by(participantId)) %>% 
  left_join(vis_distance, by = join_by(participantId)) %>% 
  mutate(phy.x = convert_to_physical_x(pixel.x, pixelToMM),
         phy.y = convert_to_physical_x(pixel.y, pixelToMM)) 
```

```{r}
#| code-fold: true 
d %>% 
  ggplot(aes(x = phy.x, y = phy.y)) + 
  geom_point() + 
  theme_minimal() + 
  labs(x = "physical distance (x) in mm", 
       y = "physical distance (y) in mm")
```

```{r}
#| code-fold: true 

task_df %>% filter(grepl("task3", trialId)) %>% 
  left_join(pixel_to_mm, by = join_by(participantId)) %>% 
  left_join(vis_distance, by = join_by(participantId)) %>% 
  mutate(phy.x = convert_to_physical_x(pixel.x, pixelToMM),
         phy.y = convert_to_physical_x(pixel.y, pixelToMM), 
         va.x = vis_angle(phy.x, dist_to_screen),
         va.y = vis_angle(phy.y, dist_to_screen),) %>% 
  ggplot(aes(x = va.x, y = va.y)) + 
  geom_point(alpha = 0.8) + 
  theme_minimal() + 
  labs(x = "visual angle (x)", 
       y = "visual angle (y)")
```


## Task 4 --- CDF Mode --- Find slope

Recall that mode is just `param.mu`. 

```{r}
task_df %>% filter(grepl("task3", trialId)) %>% 
  ggplot(aes(x = location.x, y = param.mu)) + 
  geom_point(alpha=0.5) + theme_minimal() + 
  geom_abline(slope = 1, intercept = 0, linetype="dashed", color="gray") + 
  coord_equal()
```


## Task 5 --- Project from dot to axes

```{r}
df %>% filter(grepl("task5", trialId)) %>% 
  filter(grepl("test", trialId)) %>%
  select(participantId, trialId, responseId, answer) %>% 
  mutate(answer = as.numeric(answer)) %>% 
  pivot_wider(names_from = responseId, values_from = answer, names_repair = "universal") %>% 
  separate_wider_delim(trialId, delim="_", names = c("TaskType", "type", "id")) %>% 
  select(-type) -> task_5

task_5 %>% head(5)
```

How accurate where the xs? 

```{r}
task_5 %>% 
  ggplot(aes(x = slider.x, y = location.x)) + 
  geom_point(alpha=0.5) + 
  theme_minimal() + 
  geom_abline(intercept = 0, slope = 1, color = "gray", linetype = "dashed") + 
  coord_equal()
```

How accurate where the ys? 

```{r}
task_5 %>% 
  ggplot(aes(x = slider.y, y = location.y)) + 
  geom_point(alpha=0.5) + 
  theme_minimal() + 
  geom_abline(intercept = 0, slope = 1, color = "gray", linetype = "dashed") + 
  coord_equal()
```

We can also try to plot things in data space: 

```{r}
# TODO 
```

