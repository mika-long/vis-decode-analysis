---
title: "Models Task 4 (Find slope)"
format: html
---

```{r}
#| echo: false
#| output: false
#| label: setup

library(tidyverse)
library(ggplot2)
library(sgt)
library(numDeriv)
library(ggdist)
# setting the theme 
theme_set(theme_minimal())
# model
library(brms)
# plot results 
library(tidybayes)
```

# Set up 

read in data and write functions for processing: 

```{r}
#| label: read-in-data
#| code-fold: true

df <- read.csv("vis-decode-slider_all_tidy.csv") %>% as_tibble(.)

# filter 
ids <- df %>% count(participantId) %>% filter(n == 492) %>% pull(participantId) 
df <- df %>% filter(participantId %in% ids)

# create a separate dataframe for just test related trials 
task_df <- df %>% filter(grepl("task", trialId) & grepl("test", trialId) ) %>% 
    select(participantId, trialId, responseId, answer) %>% 
    mutate(answer = as.numeric(answer)) %>% 
    pivot_wider(names_from = responseId, values_from = answer, names_repair = "universal") %>% 
  separate_wider_delim(trialId, delim = "_", names = c("task", "type", "id")) %>% 
  select(-type) %>% 
  rename(data.select.x = location.x, 
         data.select.y = location.y,
         pixel.select.x = pixel.x, 
         pixel.select.y = pixel.y)

# create a dataframe for single participant (Sheng only) 
not_sheng <- c("5f37a06e-50e4-4489-948f-c4f25bd38d17", "85349f2b-c75a-46ff-8f80-fafc92da11a7")
single_pid_df <- task_df %>% filter(!participantId %in% not_sheng)
```

```{r}
#| label: define-function
#| code-fold: true

# origin is top left  
data_to_pixel_y <- function(data_y) {
  return(-395 * data_y + 410)
}
data_to_pixel_x <- function(data_x) {
  return (53.5 * data_x + 317.5)
}

# origin is bottom left 
pixel_to_phy_x <- function(pixel, pxMM){
  (pixel - 50) / pxMM
}
pixel_to_phy_y <- function(pixel, pxMM){
  (410 - pixel) / pxMM
}

# return visual angle in degrees and not radian
vis_angle <- function(size, distance){
  return(2 * atan(size / (2 * distance)) * 180 / pi)
}

phy_to_pixel_y <- function(phy, pxMM){
  return(410 - phy * pxMM)
}

phy_to_pixel_x <- function(phy, pxMM){
  return(50 + phy * pxMM)
}

pixel_to_data_x <- function(pixel){
  return((pixel - 317.5)/53.5)
}

pixel_to_data_y <- function(pixel){
  return((410 - pixel)/395)
}

# tolerance for numerical precision 
tolerance <- 1e-10
```

```{r}
#| label: define-special-dfs
#| code-fold: true

p <- df %>% filter(participantId %in% ids) %>% 
  filter(grepl("pixelsPerMM", responseId) | grepl("prolificId", responseId)) %>% 
  select(participantId, responseId, answer) %>% 
  pivot_wider(names_from = responseId, values_from = answer) %>% 
  pull(participantId)

# custom dataframe 
pixel_to_mm <- data.frame(participantId = p, 
  pixelToMM = c(3.73, 3.27, 3.27, 5.03, 3.73, 3.25, 3.73, 3.27, 3.73, 3.27, 5.14, 3.30, 3.29)
)

vis_distance <- data.frame(participantId = p, 
                           dist_to_screen = c(426, 502, 500, 495, 485, 987, 635, 500, 479, 563, 449, 685, 462))

# combine 
participants <- pixel_to_mm %>% left_join(vis_distance, by = join_by(participantId))
```


# Task 4 -- Find slope 

```{r}
#| label: get task 4 data 

epsilon <- 1e-10

task4_df <- single_pid_df %>% filter(task == "task4") %>% 
  select(-slider.x, -slider.y) %>% 
  mutate(data.select.slope = dsgt(data.select.x, param.mu, param.sigma, param.lambda, param.p, param.q, mean.cent=FALSE), 
         data.ans.slope = dsgt(param.mu, param.mu, param.sigma, param.lambda, param.p, param.q, mean.cent=FALSE)) %>% 
  left_join(participants, by = join_by(participantId)) %>% 
  mutate(phy.select.x = pixel_to_phy_x(pixel.select.x, pixelToMM), 
         phy.select.y = pixel_to_phy_y(pixel.select.y, pixelToMM),
         va.select.x = vis_angle(phy.select.x, dist_to_screen), 
         va.select.y = vis_angle(phy.select.y, dist_to_screen)) %>%
  mutate(data.ans.x = param.mu, 
         data.ans.y = 1 / 2 * (psgt(data.ans.x + epsilon, param.mu, param.sigma, param.lambda, param.p, param.q, mean.cent = FALSE) +  
                                            psgt(data.ans.x - epsilon, param.mu, param.sigma, param.lambda, param.p, param.q, mean.cent = FALSE))) %>%
  mutate(pixel.ans.x = data_to_pixel_x(data.ans.x), 
         pixel.ans.y = data_to_pixel_y(data.ans.y)) %>% 
  mutate(phy.ans.x = pixel_to_phy_x(pixel.ans.x, pixelToMM), 
         phy.ans.y = pixel_to_phy_y(pixel.ans.y, pixelToMM)) %>% 
  mutate(va.ans.x = vis_angle(phy.ans.x, dist_to_screen), 
         va.ans.y = vis_angle(phy.ans.y, dist_to_screen)) 

```

```{r}
task4_df %>% ggplot(aes(x = va.ans.x - va.select.x)) + geom_dots()
task4_df %>% ggplot(aes(x = va.ans.y - va.select.y)) + geom_dots()
task4_df %>% ggplot(aes(x = atan(va.ans.y / va.ans.x) * 180 / pi)) + geom_dots()
task4_df %>% ggplot(aes(x = va.ans.y / va.ans.x, y = data.ans.slope)) + 
  geom_point() + coord_equal()

task4_df %>% ggplot(aes(x = data.select.slope - data.ans.slope)) + 
  geom_dots()

task4_df %>% filter(data.select.slope - data.ans.slope == 0)

task4_df %>% ggplot(aes(x = atan(data.select.slope) * 180 / pi - atan(data.ans.slope) * 180 / pi)) + 
  geom_dots()

task4_df %>% ggplot(aes(x = data_to_screen_slope(data.select.slope) - data_to_screen_slope(data.ans.slope))) + 
  geom_dots()

task4_df %>% ggplot(aes(x = atan(data_to_screen_slope(data.select.slope)) * 180 / pi - atan(data_to_screen_slope(data.ans.slope)) * 180 / pi)) + 
  # geom_dots()
  stat_ecdf()
# maybe try to fit a model here 
```

If we map the mathematical slope to the actual slope, this is what we get: 

- y axis range [0,1] correspond to 395 px -> 395px / unit 
- x axis range [-5, 5] correspond to 535 px -> 53.5 px / unit 

```{r}
data_to_screen_slope <- function(k){
  return(k * 395 / 53.5)
}

task4_df %>% ggplot(aes(x = data_to_screen_slope(data.select.slope), y = data_to_screen_slope(data.ans.slope))) + 
  geom_point(alpha = 0.5) + 
  coord_equal()

task4_df %>% ggplot(aes(x = data_to_screen_slope(data.select.slope) - data_to_screen_slope(data.ans.slope))) + 
  geom_dots()
```


Let's first see the distribution of signed error: 

```{r}
task4_df %>% ggplot(aes(x = data.select.slope - data.ans.slope)) + 
  geom_dots()

task4_df %>% ggplot(aes(y = data.select.slope - data.ans.slope, x = dist_to_screen)) + 
  geom_point(alpha = 0.5)
```

It seems that the selected slope is consistently smaller than the actual slope of the answer. 

Let's see if there's any obvious relation between signed error and parameters of the distribution: 

```{r}
#| layout-ncol: 2
#| code-fold: true 
#| output: false 

task4_df %>% ggplot(aes(y = data.select.slope - data.ans.slope, x = dist_to_screen)) + 
  geom_point()

task4_df %>% ggplot(aes(y = data.select.slope - data.ans.slope, x = param.mu)) + 
  geom_point()

task4_df %>% ggplot(aes(y = data.select.slope - data.ans.slope, x = param.sigma)) + 
  geom_point()

task4_df %>% ggplot(aes(y = data.select.slope - data.ans.slope, x = param.lambda)) + 
  geom_point()

task4_df %>% ggplot(aes(y = data.select.slope - data.ans.slope, x = param.p)) + 
  geom_point()

task4_df %>% ggplot(aes(y = data.select.slope - data.ans.slope, x = param.q)) + 
  geom_point()

task4_df %>% ggplot(aes(x = data.select.slope - data.ans.slope)) + 
  geom_dots()
```

--- 

```{r}

```

I don't get it. why is it producing these values ...? Let's debug it. 

```{r}
#| output: false 
debug(psgt)
psgt(-1, -1, 0.6, 0.2, 2.9, 5.2, mean.cent = FALSE)
undebug(psgt)
```




```{r}
x_vals <- seq(-5, 5, 0.01)
task4_df %>% select(contains("param")) %>% 
  mutate(y_vals = list(psgt(x_vals, mu = param.mu, sigma = param.sigma, lambda = param.lambda, p = param.p, q = param.q, mean.cent = FALSE)), 
         id = 1:110) %>% 
  unnest(y_vals) %>% 
  ggplot(aes(x = y_vals)) + geom_dots()
```

# Exponential Model 

For now let's model things as an exponential distribution. 

```{r}
task4_df %>% ggplot(aes(x = data_to_screen_slope(data.select.slope) - data_to_screen_slope(data.ans.slope))) + 
  geom_dots()
```

Math model: 
$$\text{error}_i \sim \text{Exponential}(\lambda)$$
$$\log(\lambda) \sim \mathcal{N}(0, 1)$$

```{r}
f <- bf(error ~ 1, 
        family = exponential())

# mu has log-link, so we don't pose any bounds on it 
p <- prior(normal(0, 1), class = Intercept)
```

Fit the model:

```{r}
#| output: false 
s.4.1 <- task4_df %>% 
  mutate(error = abs(data_to_screen_slope(data.select.slope) - data_to_screen_slope(data.ans.slope)) + epsilon) %>% 
  brm(formula = f, 
      prior = prior(normal(0, 1), class = Intercept), 
      cores = 4, 
      file = "models/s.4.1"
      )
```

Check fit: 

```{r}
summary(s.4.1)
```

```{r}
plot(s.4.1)
pp_check(s.4.1, ndraws = 100, type = "pit_ecdf")
pp_check(s.4.1, ndraws = 100)
```

```{r}
s.4.1 %>% spread_draws(b_Intercept) %>% 
  mutate(lambda = exp(b_Intercept)) %>% 
  ggplot(aes(x = lambda)) + stat_halfeye()
```

# Pareto model 

- [pareto distribution](https://en.wikipedia.org/wiki/Pareto_distribution) and its [stan implementation](https://mc-stan.org/docs/functions-reference/positive_lower-bounded_distributions.html#pareto-distribution)

TODO: check the following code is correct 

```{r}
# Define the Pareto custom family
pareto_family <- custom_family(
  "pareto",
  dpars = c("mu", "shape"),  # parameters: mu = scale, shape = alpha
  links = c("log", "log"),   # log links ensure parameters are positive
  lb = c(0, 0),              # lower bounds for both parameters
  type = "real"
)

# The Stan code for the Pareto log-likelihood function
# Note: Stan already has a built-in pareto_lpdf function
stan_funs <- "
  // Use the built-in pareto_lpdf function
  real pareto_lpdf(real y, real mu, real shape) {
    return pareto_lpdf(y | mu, shape);
  }
  
  real pareto_rng(real mu, real shape) {
    return mu * pow(1 - uniform_rng(0, 1), -1/shape);
  }
"

# Define the formula for the model
# Here we're modeling both parameters as constants
formula <- bf(
  y ~ 1,  # Intercept-only model for mu (scale parameter)
  shape ~ 1  # Intercept-only model for shape parameter
)

# Fit the model with brms
fit_pareto <- brm(
  formula = formula,
  data = df,
  family = pareto_family,
  prior = c(
    # Prior for the scale parameter (on log scale)
    prior(normal(0, 1), class = "Intercept"),
    # Prior for the shape parameter (on log scale)
    prior(normal(0, 1), class = "Intercept", dpar = "shape")
  ),
  stanvars = stanvar(scode = stan_funs, block = "functions"),
  chains = 4,
  iter = 2000,
  warmup = 1000,
  cores = 4,
  seed = 123,
  control = list(adapt_delta = 0.95)
)

# Examine model results
summary(fit_pareto)
```


