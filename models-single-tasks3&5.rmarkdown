---
title: "Single Participant, Tasks 5 and 3 models (projections)"
format:
  html: 
    code-fold: false
    reference-location: margin
    df-print: paged
    toc: true
    code-overflow: wrap
---

```{r}
#| echo: false
#| output: false
#| label: setup

library(tidyverse)
library(ggplot2)
library(sgt)
library(numDeriv)
library(ggdist)
# setting the theme 
theme_set(theme_minimal())
# model
library(brms)
# plot results 
library(tidybayes)
```


# Set up 

read in data and write functions for processing: 


```{r}
#| label: read-in-data
#| code-fold: true

df <- read.csv("vis-decode-slider_all_tidy.csv") %>% as_tibble(.)

# filter 
ids <- df %>% count(participantId) %>% filter(n == 492) %>% pull(participantId) 
df <- df %>% filter(participantId %in% ids)

# create a separate dataframe for just test related trials 
task_df <- df %>% filter(grepl("task", trialId) & grepl("test", trialId) ) %>% 
    select(participantId, trialId, responseId, answer) %>% 
    mutate(answer = as.numeric(answer)) %>% 
    pivot_wider(names_from = responseId, values_from = answer, names_repair = "universal") %>% 
  separate_wider_delim(trialId, delim = "_", names = c("task", "type", "id")) %>% 
  select(-type) %>% 
  rename(data.select.x = location.x, 
         data.select.y = location.y,
         pixel.select.x = pixel.x, 
         pixel.select.y = pixel.y)

# create a dataframe for single participant (Sheng only) 
not_sheng <- c("5f37a06e-50e4-4489-948f-c4f25bd38d17", "85349f2b-c75a-46ff-8f80-fafc92da11a7")
single_pid_df <- task_df %>% filter(!participantId %in% not_sheng)
```

```{r}
#| label: define-function
#| code-fold: true

# origin is top left  
data_to_pixel_y <- function(data_y) {
  return(-395 * data_y + 410)
}
data_to_pixel_x <- function(data_x) {
  return (53.5 * data_x + 317.5)
}

# origin is bottom left 
pixel_to_phy_x <- function(pixel, pxMM){
  (pixel - 50) / pxMM
}
pixel_to_phy_y <- function(pixel, pxMM){
  (410 - pixel) / pxMM
}

# return visual angle in degrees and not radian
vis_angle <- function(size, distance){
  return(2 * atan(size / (2 * distance)) * 180 / pi)
}

# tolerance for numerical precision 
tolerance <- 1e-10
```

```{r}
#| label: define-special-dfs
#| code-fold: true

p <- df %>% filter(participantId %in% ids) %>% 
  filter(grepl("pixelsPerMM", responseId) | grepl("prolificId", responseId)) %>% 
  select(participantId, responseId, answer) %>% 
  pivot_wider(names_from = responseId, values_from = answer) %>% 
  pull(participantId)

# custom dataframe 
pixel_to_mm <- data.frame(participantId = p, 
  pixelToMM = c(3.73, 3.27, 3.27, 5.03, 3.73, 3.25, 3.73, 3.27, 3.73, 3.27, 5.14, 3.30, 3.29)
)

vis_distance <- data.frame(participantId = p, 
                           dist_to_screen = c(426, 502, 500, 495, 485, 987, 635, 500, 479, 563, 449, 685, 462))

# combine 
participants <- pixel_to_mm %>% left_join(vis_distance, by = join_by(participantId))
```


# Task 5 --- Project from dot to axes 

Get data: 


```{r}
#| label: task 5 load data
#| code-fold: true 

task5_df <- single_pid_df %>% filter(task == "task5") %>% 
  select(participantId, task, id, data.select.x, data.select.y, slider.x, slider.y) %>% 
  rename(data.ans.x = data.select.x, 
         data.ans.y = data.select.y, 
         data.select.x = slider.x, 
         data.select.y = slider.y) %>% 
  left_join(participants, by = join_by(participantId)) %>% 
  # do all the calculations for user's selected 
  mutate(pixel.select.x = data_to_pixel_x(data.select.x), 
         pixel.select.y = data_to_pixel_y(data.select.y), 
         phy.select.x = pixel_to_phy_x(pixel.select.x, pixelToMM),
         phy.select.y = pixel_to_phy_y(pixel.select.y, pixelToMM), 
         va.select.x = vis_angle(phy.select.x, dist_to_screen),
         va.select.y = vis_angle(phy.select.y, dist_to_screen)) %>% 
  # do all the calculations for the actual answer
  mutate(pixel.ans.x = data_to_pixel_x(data.ans.x),
         pixel.ans.y = data_to_pixel_y(data.ans.y),
         phy.ans.x = pixel_to_phy_x(pixel.ans.x, pixelToMM),
         phy.ans.y = pixel_to_phy_y(pixel.ans.y, pixelToMM), 
         va.ans.x = vis_angle(phy.ans.x, dist_to_screen),
         va.ans.y = vis_angle(phy.ans.y, dist_to_screen))
```


Verify that the results are in the right scale: 


```{r}
#| output: false 
#| code-fold: true
#| label: task 5 verify 

task5_df %>% ggplot(aes(x = pixel.select.x - pixel.ans.x)) + 
  geom_dots()

task5_df %>% ggplot(aes(x = pixel.select.y - pixel.ans.y)) + 
  geom_dots()

task5_df %>% ggplot(aes(x = phy.select.x - phy.ans.x)) + 
  geom_dots()  

task5_df %>% ggplot(aes(x = phy.select.y - phy.ans.y)) + 
  geom_dots() 

task5_df %>% ggplot(aes(x = va.select.x - va.ans.x)) + 
  geom_dots()  

task5_df %>% ggplot(aes(x = va.select.y - va.ans.y)) + 
  geom_dots()  

```


## Model Fitting Overview 
- Models can be fitted in visual angle space, as well as physical space 
- Within each space, the effect of "distance to the other axis" could be *multiplicative* or *additive*. [TO BE INVESTIGATED]
- We could start with a single participant, before extending to multiple participants 

## Task 5.1 --- Project from dot to X axes

Distribution of signed error: 


```{r}
#| code-fold: true

task5_df %>% ggplot(aes(x = va.select.x - va.ans.x)) + 
  geom_dots() +
  geom_vline(xintercept = 0, linetype="dashed", color="black") + 
  labs(title="Task 5 - Project from Dot to X-Axes - Vis Angle") 
```


- This doesn't quite look normal, but more like a _skewed_ normal distribution ... 

Relationship between signed error (in visual angle space) and distance to X-axes: 


```{r}
#| code-fold: true

task5_df %>% ggplot(aes(y = va.ans.y, x = va.select.x - va.ans.x)) + 
  geom_point(alpha = 0.5) +
  geom_vline(xintercept = 0, linetype="dashed", color="gray") + 
  labs(title="Task 5 - Project from Dot to X-Axes - Vis Angle")
```


### Task 5.1 --- Vis Angle Model

$$\begin{aligned}
\texttt{error_va}_i &\sim \mathcal{N}(0, \sigma_i) \\ 
\sigma_i &= f(d_i) \,\, \text{where} \,\, d_i = \texttt{va.ans.y}_i
\end{aligned}$$

**Option 1**: $\sigma_i = f(d_i) = \log(\alpha + \beta \times \texttt{va.ans.y}_i)$


```{r}
f <- bf(error_va ~ 0, 
        sigma ~ 1 + va.ans.y) # offset(log(va.ans.y))

p <- c(
  prior(normal(0, 1), class = Intercept, dpar = sigma),           # this is alpha 
  prior(normal(0, 1), class = b, coef = "va.ans.y", dpar = sigma) # this is beta 
)
```

```{r}
#| eval: false 
#| echo: false 

task5_df %>% mutate(error_va = va.select.x - va.ans.x) %>%
get_prior(formula = f,
          data = .)

task5_df %>% mutate(error_va = va.select.x - va.ans.x) %>%
make_stancode(f, data = ., prior = p, family = gaussian())
```



Fit model: 


```{r}
#| output: false 

s.5x.va.1 <- task5_df %>% mutate(error_va = va.select.x - va.ans.x) %>%
  # account for numerical precision 
  mutate(error_va = ifelse(abs(error_va) < tolerance, 0, error_va)) %>% 
  # account for bugs in task 5 
  filter(va.ans.y != 0) %>% 
  brm(
    formula = f,
    prior = p,
    data = .,
    family = gaussian(),
    chains = 4, 
    file = "models/s.5x.va.1", 
    save_pars = save_pars(all = TRUE)
)
```

```{r}
summary(s.5x.va.1)
```

```{r}
#| layout-ncol: 2
plot(s.5x.va.1)
pp_check(s.5x.va.1, ndraws = 100)
```


Check the posterior estimations of `alpha` and `beta`: 


```{r}
s.5x.va.1 %>% spread_draws(`b_sigma_.*`, regex=TRUE)
```


---

**Option 2**: $\sigma_i = f(d_i) = \log(\beta \times \texttt{va.ans.y}_i)$


```{r}
f <- bf(error_va ~ 0, 
        sigma ~ 0 + va.ans.y) # offset(log(va.ans.y))

p <- c(
  # prior(normal(0, 1), class = Intercept, dpar = sigma),           # this is alpha 
  prior(normal(0, 1), class = b, coef = "va.ans.y", dpar = sigma) # this is beta 
)
```

```{r}
#| eval: false 
#| echo: false 

task5_df %>% mutate(error_va = va.select.x - va.ans.x) %>%
get_prior(formula = f,
          data = .)

task5_df %>% mutate(error_va = va.select.x - va.ans.x) %>%
make_stancode(f, data = ., prior = p, family = gaussian())
```


Fit model: 


```{r}
#| output: false 

s.5x.va.2 <- task5_df %>% mutate(error_va = va.select.x - va.ans.x) %>%
  # account for numerical precision 
  mutate(error_va = ifelse(abs(error_va) < tolerance, 0, error_va)) %>% 
  # account for bugs in task 5 
  filter(va.ans.y != 0) %>% 
  brm(
    formula = f,
    prior = p,
    data = .,
    family = gaussian(),
    chains = 4, 
    file = "models/s.5x.va.2", 
    save_pars = save_pars(all = TRUE)
)
```

```{r}
summary(s.5x.va.2)
```

```{r}
#| layout-ncol: 2
plot(s.5x.va.2)
pp_check(s.5x.va.2, ndraws = 100)
```


Huh somehow this is really bad? 


```{r}
s.5x.va.2 %>% spread_draws(`^b.*`, regex = TRUE) %>% 
  mutate(beta = exp(b_sigma_va.ans.y)) %>% 
  ggplot(aes(x = beta)) +
  stat_halfeye()
```


--- 

Is there a way to make sigma not a log link??? 

`# TODO` 

### Task 5.1 --- Physical Model

Math model:

$$\begin{aligned}
\text{error_phy}_i / \texttt{dist_to_screen}  &\sim \mathcal{N}(0, \sigma_{i}) \\
\sigma_i &= f(d_i) \,\, \text{where} \,\, d_i = \texttt{phy.ans.y}_i / \texttt{dist_to_screen}
\end{aligned}$$

**Option 1**: $\sigma_i = f(d_i) = \exp(\alpha + \beta d_i)$


```{r}
f <- bf(error_phy.adj ~ 0,
        sigma ~ 1 + phy.ans.y.adj)

p <- c(
  prior(normal(0, 1), class = Intercept, dpar = sigma),
  prior(normal(0, 1), class = b, coef = phy.ans.y.adj, dpar = sigma)
)
```

```{r}
#| eval: false 
#| echo: false 

task5_df %>% mutate(error_phy = phy.select.x - phy.ans.x) %>%
  mutate(error_phy.adj = error_phy / dist_to_screen, 
         phy.ans.y.adj = phy.ans.y / dist_to_screen) %>% 
  get_prior(f, data = .)

task5_df %>% mutate(error_phy = phy.select.x - phy.ans.x) %>%
  mutate(error_phy.adj = error_phy / dist_to_screen, 
         phy.ans.y.adj = phy.ans.y / dist_to_screen) %>% 
  make_stancode(f, data = ., prior = p)
```


Fit the model:


```{r}
s.5x.phy.1 <- task5_df %>%
  mutate(error_phy = phy.select.x - phy.ans.x) %>%
  mutate(error_phy = ifelse(abs(error_phy) < tolerance, 0, error_phy)) %>%
  filter(va.ans.y != 0) %>% # account for weird bugs
  mutate(error_phy = phy.select.x - phy.ans.x) %>%
  mutate(error_phy.adj = error_phy / dist_to_screen, 
         phy.ans.y.adj = phy.ans.y / dist_to_screen) %>% 
  brm(
    formula = f,
    prior = p,
    chains = 4, 
    file = "models/s.5x.phy.1"
  )
```


Check fit and posterior: 


```{r}
summary(s.5x.phy.1)
```

```{r}
#| layout-ncol: 2
plot(s.5x.phy.1)
pp_check(s.5x.phy.1, ndraws = 100)
```


---

**Option 2**: $\sigma_i = f(d_i) = \exp(\beta d_i)$


```{r}
f <- bf(error_phy.adj ~ 0,
        sigma ~ 0 + phy.ans.y.adj)

p <- c(
  # prior(normal(0, 1), class = Intercept, dpar = sigma),
  prior(normal(0, 1), class = b, coef = phy.ans.y.adj, dpar = sigma)
)
```


Fit the model:


```{r}
#| output: false 
s.5x.phy.2 <- task5_df %>%
  mutate(error_phy = phy.select.x - phy.ans.x) %>%
  mutate(error_phy = ifelse(abs(error_phy) < tolerance, 0, error_phy)) %>%
  filter(va.ans.y != 0) %>% # account for weird bugs
  mutate(error_phy = phy.select.x - phy.ans.x) %>%
  mutate(error_phy.adj = error_phy / dist_to_screen, 
         phy.ans.y.adj = phy.ans.y / dist_to_screen) %>% 
  brm(
    formula = f,
    prior = p,
    chains = 4, 
    file = "models/s.5x.phy.2"
  )
```


Check fit and posterior: 


```{r}
summary(s.5x.phy.2)
```

```{r}
#| layout-ncol: 2

plot(s.5x.phy.2)
pp_check(s.5x.phy.2, ndraws = 100)
```


Check posterior: 


```{r}
s.5x.phy.2 %>% spread_draws(`b_.*`, regex=TRUE) %>% 
  mutate(beta = exp(b_sigma_phy.ans.y.adj)) %>% 
  ggplot(aes(beta)) + 
  stat_halfeye()
```


I really don't think the physical model is the right one ... 

## Task 5.2 --- Project from dot to Y Axes

Distribution of signed error:


```{r}
#| code-fold: true

task5_df %>% ggplot(aes(x = va.select.y - va.ans.y)) +
  geom_dots() +
  geom_vline(xintercept = 0, color="black", linetype="dashed") +
  labs(title = "Task 5 - Project from dot to Y-Axes - Visual Angle")
```


Relationship between signed error and distance to x-axes (in visual angle space):


```{r}
#| code-fold: true

task5_df %>% ggplot(aes(x = va.ans.x, y = va.select.y - va.ans.y)) +
  geom_point(alpha = 0.5) +
  geom_hline(yintercept = 0, linetype="dashed", color="gray") +
  labs(title = "Task 5 - Project from dot to Y-Axes - Visual Angle")
```


We apply the same approach, fit two models, and compare them.

### Task 5.2 --- Vis Angle Model

**Option 1**: $\sigma_i = f(d_i) = \exp(\alpha + \beta d_i)$


```{r}
f <- bf(error_va ~ 0,
        sigma ~ 1 + va.ans.x) # what's the difference between this and 0 + offset(log(va.ans.x)) ???

p <- c(
  prior(normal(0, 1), class = Intercept, dpar = sigma), 
  prior(normal(0, 1), class = b, coef = va.ans.x, dpar = sigma)
)
```

```{r}
#| eval: false 
#| echo: false 

task5_df %>% mutate(error_va = va.select.y - va.ans.y) %>%
get_prior(formula = f,
          data = .)

task5_df %>% mutate(error_va = va.select.y - va.ans.y) %>%
make_stancode(formula = f,
              data = ., 
              prior = p)
```


Fit the model: 


```{r}
#| output: false 
s.5y.va.1 <- task5_df %>% mutate(error_va = va.select.y - va.ans.y) %>%
  # account for numerical precision 
  mutate(error_va = ifelse(abs(error_va) < tolerance, 0, error_va)) %>% 
  # account for bugs in task 5 
  filter(va.ans.y != 0) %>% 
  brm(
    formula = f,
    prior = p,
    data = .,
    family = gaussian(),
    chains = 4, 
    file = "models/s.5y.va.1", 
    save_pars = save_pars(all = TRUE)
)
```


Check fit and posterior: 


```{r}
summary(s.5y.va.1)
```

```{r}
#| layout-ncol: 2

plot(s.5y.va.1)
pp_check(s.5y.va.1, ndraws = 100)
```


---

**Option 2**: $\sigma_i = f(d_i) = \exp(\beta d_i)$


```{r}
f <- bf(error_va ~ 0,
        sigma ~ 0 + va.ans.x) # what's the difference between this and 0 + offset(log(va.ans.x)) ???

p <- c(
  # prior(normal(0, 1), class = Intercept, dpar = sigma), 
  prior(normal(0, 1), class = b, coef = va.ans.x, dpar = sigma)
)
```

```{r}
#| eval: false 
#| echo: false 

task5_df %>% mutate(error_va = va.select.y - va.ans.y) %>%
get_prior(formula = f,
          data = .)

task5_df %>% mutate(error_va = va.select.y - va.ans.y) %>%
make_stancode(formula = f,
              data = ., 
              prior = p)
```


Fit the model: 


```{r}
#| output: false 
s.5y.va.2 <- task5_df %>% mutate(error_va = va.select.y - va.ans.y) %>%
  # account for numerical precision 
  mutate(error_va = ifelse(abs(error_va) < tolerance, 0, error_va)) %>% 
  # account for bugs in task 5 
  filter(va.ans.y != 0) %>% 
  brm(
    formula = f,
    prior = p,
    data = .,
    family = gaussian(),
    chains = 4, 
    file = "models/s.5y.va.2", 
    save_pars = save_pars(all = TRUE)
)
```


Check fit and posterior: 


```{r}
summary(s.5y.va.2)
```

```{r}
#| layout-ncol: 2

plot(s.5y.va.2)
pp_check(s.5y.va.2, ndraws = 100)
```


Again, without the intercept the posterior check looks weird. Let's check beta: 


```{r}
s.5y.va.2 %>% spread_draws(`^b.*`, regex = TRUE) %>% 
  mutate(beta = exp(b_sigma_va.ans.x)) %>% 
  ggplot(aes(x = beta)) + 
  stat_halfeye()
```


Hmm this seems to be a bit larger than the one before ... 

### Task 5.2 --- Physical Model

`#TODO` 

# Task 3 -- Find point on curve where `y == 0.5`

First we get the data:


```{r}
task3_df <- single_pid_df %>% filter(task == "task3") %>%
  select(-slider.x, -slider.y) %>%
  left_join(participants, by = join_by(participantId)) %>%
  # do all the calculations for user's selected
  mutate(pixel.select.x = data_to_pixel_x(data.select.x),
         pixel.select.y = data_to_pixel_y(data.select.y),
         phy.select.x = pixel_to_phy_x(pixel.select.x, pixelToMM),
         phy.select.y = pixel_to_phy_y(pixel.select.y, pixelToMM),
         va.select.x = vis_angle(phy.select.x, dist_to_screen),
         va.select.y = vis_angle(phy.select.y, dist_to_screen)) %>%
  mutate(data.ans.y = 0.5,
         data.ans.x = qsgt(0.5, param.mu, param.sigma, param.lambda, param.p, param.q, mean.cent = FALSE)) %>%
  # do all the calculations for the actual answer
  mutate(pixel.ans.x = data_to_pixel_x(data.ans.x),
         pixel.ans.y = data_to_pixel_y(data.ans.y),
         phy.ans.x = pixel_to_phy_x(pixel.ans.x, pixelToMM),
         phy.ans.y = pixel_to_phy_y(pixel.ans.y, pixelToMM),
         va.ans.x = vis_angle(phy.ans.x, dist_to_screen),
         va.ans.y = vis_angle(phy.ans.y, dist_to_screen))
```


Verify that the scales are correct:


```{r}
#| output: false
#| code-fold: true
#| label: task 3 verify

# verify that the results are of correct scale
task3_df %>% ggplot(aes(x = data.select.x - data.ans.x)) +
  geom_dots()

task3_df %>% ggplot(aes(x = data.select.y - data.ans.y)) +
  geom_dots()

task3_df %>% ggplot(aes(x = pixel.select.x - pixel.ans.x)) +
  geom_dots()

task3_df %>% ggplot(aes(x = pixel.select.y - pixel.ans.y)) +
  geom_dots()

task3_df %>% ggplot(aes(x = phy.select.x - phy.ans.x)) +
  geom_dots()

task3_df %>% ggplot(aes(x = phy.select.y - phy.ans.y)) +
  geom_dots()

task3_df %>% ggplot(aes(x = va.select.x - va.ans.x)) +
  geom_dots()

task3_df %>% ggplot(aes(x = va.select.y - va.ans.y)) +
  geom_dots()
```


Distribution of signed error:


```{r}
#| code-fold: true

task3_df %>% ggplot(aes(x = va.select.y - va.ans.y)) +
  geom_dots() +
  geom_vline(xintercept = 0, linetype="dashed", color="black") +
  labs(title="Task 3 -- CDF Median")
```


Relationship between distance from the y-axes and the signed distribution:


```{r}
task3_df %>% ggplot(aes(x = va.ans.x, y = va.select.y - va.ans.y)) +
  geom_point(alpha = 0.5) +
  geom_hline(yintercept = 0, linetype="dashed", color="black") +
  labs(title="Task 3 -- CDF Median")
```


Math model:

$$\begin{align*}
\text{error_va}_{i} &\sim \mathcal{N}(0, \sigma) \\
\sigma &= f(d_i) \,\, \text{where} \,\, d_i = \texttt{va.ans.x}_i
\end{align*}$$

### Task 3 --- Visual Angle Model

**Option 1**: $\sigma_i = f(d_i) = \exp(\alpha + \beta \cdot d_i)$


```{r}
f <- bf(error_va ~ 0,
        sigma ~ 1 + va.ans.x)

p <- c(
  prior(normal(0, 1), class = Intercept, dpar = sigma), 
  prior(normal(0, 1), class = b, dpar = sigma)
)
```

```{r}
#| eval: false 
#| echo: false 

task3_df %>% mutate(error_va = va.select.y - va.ans.y) %>%
get_prior(formula = f,
          data = .)

task3_df %>% mutate(error_va = va.select.y - va.ans.y) %>%
make_stancode(formula = f,
              data = ., 
              prior = p)
```


Fit the model:


```{r}
#| output: false

s.3.va.1 <- task3_df %>%
  mutate(error_va = va.select.y - va.ans.y) %>%
  mutate(error_va = ifelse(abs(error_va) < tolerance, 0, error_va)) %>%
  brm(
    formula = f,
    data = .,
    family = gaussian(),
    prior = p,
    chains = 4,
    file="models/s.3.va.1",
    save_pars = save_pars(all=TRUE)
)
```

```{r}
summary(s.3.va.1)
```

```{r}
#| layout-ncol: 2
plot(s.3.va.1)
pp_check(s.3.va.1, ndraws = 100)
```


---

**Option 2**: $\sigma_i = f(d_i) = \exp(\beta \cdot d_i)$


```{r}
f <- bf(error_va ~ 0, 
        sigma ~ 0 + va.ans.x)

p <- c(
  # prior(normal(0, 1), class = Intercept, dpar = sigma), 
  prior(normal(0, 1), class = b, dpar = sigma)
)
```


Fit the model:


```{r}
#| output: false

s.3.va.2 <- task3_df %>%
  mutate(error_va = va.select.y - va.ans.y) %>%
  mutate(error_va = ifelse(abs(error_va) < tolerance, 0, error_va)) %>%
  brm(
    formula = f,
    data = .,
    family = gaussian(),
    prior = p,
    chains = 4,
    file="models/s.3.va.2",
    save_pars = save_pars(all=TRUE)
)
```


Check fit and posterior: 


```{r}
summary(s.3.va.2)
```

```{r}
#| layout-ncol: 2

plot(s.3.va.2)
pp_check(s.3.va.2, ndraws = 100)
```


Lets see the posterior of beta: 


```{r}
s.3.va.2 %>% spread_draws(`^b_.*`, regex = TRUE) %>% 
  mutate(beta = exp(b_sigma_va.ans.x)) %>% 
  ggplot(aes(x = beta)) + 
  stat_halfeye()
```


This is similar to the results we obtained for the other stuff. 

### Task 3 Physical Model

**TODO** 

<!-- ```{r} -->
<!-- f <- bf(error_phy ~ 0,  -->
<!--         sigma ~ 0 + offset(log(phy.ans.x + dist_to_screen))) -->
<!-- p <- prior(constant(1), class = "sd", group = "participantId", dpar="sigma") -->
<!-- ``` -->

<!-- Fit the model:  -->

<!-- ```{r} -->
<!-- #| label: task3-fit-model-2 -->
<!-- #| output: false  -->

<!-- m3.2 <- task3_df %>%  -->
<!--   mutate(error_phy = phy.select.y - phy.ans.y) %>%  -->
<!--   mutate(error_phy = ifelse(abs(error_phy) < tolerance, 0, error_phy)) %>% -->
<!--   brm(  -->
<!--     formula = f,  -->
<!--     data = .,  -->
<!--     family = gaussian(), -->
<!--     prior = p, -->
<!--     control = list(adapt_delta = 0.95), -->
<!--     chains = 4,  -->
<!--     iter = 6000,  -->
<!--     file="models/m3.2", -->
<!--     save_pars = save_pars(all = TRUE) -->
<!-- ) -->
<!-- ``` -->

<!-- Plot the results:  -->

<!-- ```{r} -->
<!-- summary(m3.2) -->
<!-- plot(m3.2) -->
<!-- pp_check(m3.2, ndraws = 100) -->
<!-- ``` -->

# Compare the models 

- across the difference spaces 

**TODO** 




