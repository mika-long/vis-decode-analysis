---
title: "Analysis - Task 3, Task 5"
format: 
  html: 
    code-fold: false
    reference-location: margin
    df-print: paged
    toc: true
    code-overflow: wrap
---

```{r}
#| echo: false
#| output: false
#| label: setup 

library(tidyverse)
library(ggplot2)
library(sgt)
library(numDeriv)
library(ggdist)
# setting the theme 
theme_set(theme_minimal() + theme(base_size = 6))
# model
library(brms)
# plot results 
library(tidybayes)
library(modelr)
library(patchwork)
```

# Set up

Read in data 

```{r}
#| label: read-in-data
#| code-fold: true

df1 <- read.csv("pilot-01.csv") %>% as_tibble(.)

df <- read.csv("pilot-02.csv") %>% as_tibble(.) %>% 
  bind_rows(df1)

exclude_participants <- c("67fd4f955123c6d79ae66a3a", "67eedf7be13ffb77c677d4dd", "6443ebb84fc33e703937a6f9")

task_df <- df %>% filter(status == "completed") %>% 
  select(participantId, trialId, responseId, answer) %>%
  filter(str_detect(trialId, "task")) %>%
  mutate(answer = as.numeric(answer)) %>% 
  pivot_wider(names_from = responseId, values_from = answer, names_repair = "universal") %>% 
  separate_wider_delim(trialId, delim = "_", names = c("task", "type", "id")) %>% 
  filter(type != "train") %>% 
  select(-type) %>% 
  rename(data.select.x = location.x, 
         data.select.y = location.y,
         pixel.select.x = pixel.x, 
         pixel.select.y = pixel.y) %>% 
  filter(!participantId %in% exclude_participants)
```

```{r}
#| label: define-function
#| code-fold: true

# origin is top left  
data_to_pixel_y <- function(data_y) {
  return(-395 * data_y + 410)
}
data_to_pixel_x <- function(data_x) {
  return (53.5 * data_x + 317.5)
}

# origin is bottom left 
pixel_to_phy_x <- function(pixel, pxMM){
  (pixel - 50) / pxMM
}
pixel_to_phy_y <- function(pixel, pxMM){
  (410 - pixel) / pxMM
}

# return visual angle in degrees and not radian
vis_angle <- function(size, distance){
  return(2 * atan(size / (2 * distance)) * 180 / pi)
}

# tolerance for numerical precision 
tolerance <- 1e-10
```

```{r}
#| label: define-special-dfs
#| code-fold: true

p <- df %>% filter(status == "completed") %>% 
  select(participantId, trialId, responseId, answer) %>% 
  filter(grepl("calibration", trialId))

p %>% filter(responseId == "ball-positions") %>% 
  select(participantId, answer) %>% 
  mutate(answer = gsub("\\[|\\]", "", answer)) %>% 
  mutate(split_answer = str_split(answer, ",")) %>% 
  mutate(numeric_vectors = map(split_answer, ~ as.numeric(.x))) %>% 
  unnest(split_answer) %>% 
  mutate(split_answer = as.numeric(split_answer)) %>% 
  group_by(participantId) %>% 
  summarise(avg.ball.pos = sum(split_answer) / 5, 
            min.ball.pos = min(split_answer),
            max.ball.pos = max(split_answer)) -> avg_ball_pos

avg_ball_pos %>% mutate(true_ball_pos = (avg.ball.pos * 5 - min.ball.pos - max.ball.pos)/3) %>% 
  select(participantId, true_ball_pos) -> true_ball_pos

participants <- p %>% filter(grepl("pixelsPerMM|dist-calibration-MM", responseId)) %>%
  select(-trialId) %>%
  mutate(answer = as.numeric(answer)) %>%
  pivot_wider(names_from = responseId, values_from = answer) %>%
  rename(pixelToMM = pixelsPerMM, dist_to_screen = `dist-calibration-MM`) %>%
  filter(!participantId %in% exclude_participants) %>%
  left_join(avg_ball_pos) %>% 
  mutate(phy = dist_to_screen * tan(13.5 * pi / 180), 
         px = phy * pixelToMM, 
         square_pos = round(px + avg.ball.pos))

participants %>% left_join(true_ball_pos) %>% 
  mutate(ball.square.dist = (square_pos - true_ball_pos) / pixelToMM, 
         d = ball.square.dist / tan(13.5 * pi / 180)) %>% 
  select(participantId, pixelToMM, d) %>% 
  rename(dist_to_screen = d) -> participants
```

# Task 5 --- Project from dot to axes 

Get the data: 

```{r}
#| label: task 5 load data
#| code-fold: true 

task5_df <- task_df %>% filter(task == "task5") %>% # or use task_df for full 
  select(participantId, task, id, data.select.x, data.select.y, slider.x, slider.y) %>% 
  rename(data.ans.x = data.select.x, 
         data.ans.y = data.select.y, 
         data.select.x = slider.x, 
         data.select.y = slider.y) %>% 
  left_join(participants, by = join_by(participantId)) %>% 
  # do all the calculations for user's selected 
  mutate(pixel.select.x = data_to_pixel_x(data.select.x), 
         pixel.select.y = data_to_pixel_y(data.select.y), 
         phy.select.x = pixel_to_phy_x(pixel.select.x, pixelToMM),
         phy.select.y = pixel_to_phy_y(pixel.select.y, pixelToMM), 
         va.select.x = vis_angle(phy.select.x, dist_to_screen),
         va.select.y = vis_angle(phy.select.y, dist_to_screen)) %>% 
  # do all the calculations for the actual answer
  mutate(pixel.ans.x = data_to_pixel_x(data.ans.x),
         pixel.ans.y = data_to_pixel_y(data.ans.y),
         phy.ans.x = pixel_to_phy_x(pixel.ans.x, pixelToMM),
         phy.ans.y = pixel_to_phy_y(pixel.ans.y, pixelToMM), 
         va.ans.x = vis_angle(phy.ans.x, dist_to_screen),
         va.ans.y = vis_angle(phy.ans.y, dist_to_screen))
```

## Project to X-Axis 

Math: 

$$\begin{align*}
\texttt{error}_i &\sim \mathcal{N}(\mu_\text{PID}[i], \sigma_{i, \text{PID}[i]}) \\ 
\mu_j &\sim \mathcal{N}{\overline{\mu}, \overline{\sigma}^2)\\ 
\log(\sigma_{i, j}) &= \alpha_j + \log(\texttt{va.ans.y}_i) \\ 
\alpha_j &\sim N(\mu_\alpha, \sigma_\alpha) \\ 
\mu_\alpha, \bar{\mu} &\sim N(0, 1) \\ 
\sigma_\alpha, \bar{\sigma} &\sim \text{Half-Cauchy}(0, 1)
\end{align*}$$

Formula and prior: 

```{r}
f <- bf(error_va ~ (1 | participantId),  
        sigma ~ (1 | participantId) + offset(log(va.ans.y)))
 
p <- c(
  prior(normal(0, 1), class = Intercept),
  prior(cauchy(0, 1), class = sd, group = participantId, lb = 0), 
  prior(normal(0, 1), class = Intercept, dpar = "sigma"), 
  prior(cauchy(0, 1), class = sd, group = participantId, dpar = sigma, lb = 0)
)
```

```{r}
#| echo: false 
#| output: false 
#| eval: false

task5_df %>% mutate(error_va = va.select.x - va.ans.x) %>%
  get_prior(formula = f,
            data = .)

task5_df %>% mutate(error_va = va.select.x - va.ans.x) %>%
  make_stancode(f, data = ., prior = p, family = gaussian())

task5_df %>% mutate(error_va = va.select.x - va.ans.x) %>%
  make_standata(f, data = ., prior = p, family = gaussian())
```

Fit model: 

```{r}
#| output: false 
m.5.x.va <- task5_df %>% mutate(error_va = va.select.x - va.ans.x) %>%
  # account for numerical precision 
  # mutate(error_va = ifelse(abs(error_va) < tolerance, 0, error_va)) %>% 
  brm(
    formula = f,
    data = .,
    family = gaussian(),
    prior = p,
    chains = 4, 
    # cores = 4,
    control = list(adapt_delta = 0.99),
    iter = 6000, 
    file = "models/task5.x", 
    save_pars = save_pars(all = TRUE)
)
```

Check fit and posterior: 

```{r}
summary(m.5.x.va)
plot(m.5.x.va)
pp_check(m.5.x.va, ndraws = 100)
```

Average effect: 

```{r}
m.5.x.va %>% get_variables(.)

# Extract posterior samples using spread_draws
m.5.x.va %>% spread_draws(b_sigma_Intercept) %>% 
  mutate(b_sigma = exp(b_sigma_Intercept)) %>% 
  ggplot(aes(x = b_sigma)) + 
  stat_halfeye()
```

Plot existing data on top of prediction: 

```{r}
# for an average participant 

task5_df %>% mutate(error_va = va.select.x - va.ans.x) %>%
  # account for numerical precision 
  mutate(error_va = ifelse(abs(error_va) < tolerance, 0, error_va)) %>% 
  data_grid(va.ans.y = seq_range(va.ans.y, n = 101)) %>% 
  mutate(error_va = 0) %>% 
  add_epred_draws(m.5.x.va, dpar = "sigma", re_formula = NA)

prediction_grid <- task5_df %>% data_grid(va.ans.y = seq_range(va.ans.y, n = 50)) %>% 
  add_predicted_draws(m.5.x.va, re_formula = NA, ndraws = 100)

ggplot(prediction_grid, aes(x = va.ans.y, y = .prediction)) + 
  stat_lineribbon(
    .width = c(.95, .80, .50),
    alpha = 0.5, 
    size = 0.5
  ) + scale_fill_brewer(palette = "Blues") + 
  geom_point(data = task5_df, aes(y = va.select.x - va.ans.x, x = va.ans.y), alpha = 0.8, size = 0.5) +
  labs(title = "Task 5 (Project to X)", y = "Signed Error", x = "Distance to X-Axis") -> p1 # + 
  # theme(text = element_text(family = "Helvetica Neue")) -> p

p1
```

```{r}
#| eval: false 
#| echo: false 

# save 
ggsave("plots/task5-project-x.pdf", p1, height = 5, width = 10, units = "cm", dpi = 300)
```

## Task 5 -- Project to Y-Axis 

Math: 

$$\begin{align*}
\texttt{error}_i &\sim \mathcal{N}(0, \sigma_{i, \text{PID}[i]}) \\ 
\log(\sigma_{i, j}) &= \alpha_j + \log(\texttt{va.ans.x}_i) \\ 
\alpha_j &\sim N(\mu_\alpha, \sigma_\alpha) \\ 
\mu_\alpha &\sim N(0, 1) \\ 
\sigma_\alpha &\sim \text{Half-Cauchy}(0, 1)
\end{align*}$$

Formula and prior: 

```{r}
f <- bf(error_va ~ (1 | participantId), 
        sigma ~ (1|participantId) + offset(log(va.ans.x)))

p <- c(
  prior(normal(0, 1), class = Intercept),
  prior(cauchy(0, 1), class = sd, group = participantId, lb = 0), 
  prior(normal(0, 1), class = Intercept, dpar = "sigma"), 
  prior(cauchy(0, 1), class = sd, group = participantId, dpar = sigma, lb = 0)
)
```

```{r}
#| echo: false 
#| output: false 
#| eval: false

task5_df %>% mutate(error_va = va.select.y - va.ans.y) %>%
  get_prior(formula = f,
            data = .)

task5_df %>% mutate(error_va = va.select.y - va.ans.y) %>%
  make_stancode(f, data = ., prior = p, family = gaussian())

task5_df %>% mutate(error_va = va.select.y - va.ans.y) %>%
  make_standata(f, data = ., prior = p, family = gaussian())
```

Fit model: 

```{r}
#| output: false 
m.5.y.va <- task5_df %>% mutate(error_va = va.select.y - va.ans.y) %>%
  # account for numerical precision 
  # mutate(error_va = ifelse(abs(error_va) < tolerance, 0, error_va)) %>% 
  brm(
    formula = f,
    data = .,
    family = gaussian(),
    prior = p,
    chains = 4, 
    # cores = 4,
    control = list(adapt_delta = 0.99),
    iter = 6000, 
    file = "models/task5.y", 
    save_pars = save_pars(all = TRUE)
)
```

Check fit and posterior: 

```{r}
summary(m.5.y.va)
plot(m.5.y.va)
pp_check(m.5.y.va, ndraws = 100)
```

Plot results: 

```{r}
prediction_grid <- task5_df %>% data_grid(va.ans.x = seq_range(va.ans.x, n = 50)) %>% 
  add_predicted_draws(m.5.y.va, re_formula = NA, ndraws = 100)

ggplot(prediction_grid, aes(x = va.ans.x, y = .prediction)) + 
  stat_lineribbon(
    .width = c(.95, .80, .50),
    alpha = 0.5, 
    size = 0.5
  ) + scale_fill_brewer(palette = "Blues")  + 
  geom_point(data = task5_df, 
             aes(y = va.select.y - va.ans.y, x = va.ans.x), 
             alpha = 0.8, 
             size = 0.5) + 
  # ylim(-0.5, 0.5) + 
  labs(title = "Task 5 (Project to Y)", y = "Signed Error", x = "Distance to Y-Axis") -> p2 # + 
  # theme(text = element_text(family = "Helvetica Neue")) -> p

p2
```

```{r}
#| echo: false 
#| eval: false 

ggsave("plots/task5-project-y.pdf", p2, height = 5, width = 10, units = "cm", dpi = 300)
```


Combine and save: 

```{r}
combined <- (p1 + guides(color = "none", fill = "none", size = "none")) / (p2 +
  guides(color = "none", fill = "none", size = "none"))

combined <- (p1 + theme(legend.position = "top")) + (p2 + theme(legend.position = "top"))

ggsave("plots/task5-combined.svg", combined, height = 8, width = 10, units = "cm", dpi = 300)
ggsave("plots/task5-combined.pdf", combined, height = 8, width = 10, units = "cm", dpi = 300)
```


# Task 3 --- Find where y == 0.5 

Get data: 

```{r}
#| label: Get task 3 data

task3_df <- task_df %>% filter(task == "task3") %>% 
  select(-slider.x, -slider.y) %>% 
  left_join(participants, by = join_by(participantId)) %>% 
  # do all the calculations for user's selected 
  mutate(pixel.select.x = data_to_pixel_x(data.select.x), 
         pixel.select.y = data_to_pixel_y(data.select.y), 
         phy.select.x = pixel_to_phy_x(pixel.select.x, pixelToMM),
         phy.select.y = pixel_to_phy_y(pixel.select.y, pixelToMM), 
         va.select.x = vis_angle(phy.select.x, dist_to_screen),
         va.select.y = vis_angle(phy.select.y, dist_to_screen)) %>% 
  mutate(data.ans.y = 0.5, 
         data.ans.x = qsgt(0.5, param.mu, param.sigma, param.lambda, param.p, param.q, mean.cent = FALSE)) %>% 
  # do all the calculations for the actual answer
  mutate(pixel.ans.x = data_to_pixel_x(data.ans.x),
         pixel.ans.y = data_to_pixel_y(data.ans.y),
         phy.ans.x = pixel_to_phy_x(pixel.ans.x, pixelToMM),
         phy.ans.y = pixel_to_phy_y(pixel.ans.y, pixelToMM), 
         va.ans.x = vis_angle(phy.ans.x, dist_to_screen),
         va.ans.y = vis_angle(phy.ans.y, dist_to_screen))
```

Math: 

$$\begin{align*}
\texttt{error}_i &\sim \mathcal{N}(0, \sigma_{i, \text{PID}[i]}) \\ 
\log(\sigma_{i, j}) &= \alpha_j + \log(\texttt{va.ans.x}_i) \\ 
\alpha_j &\sim N(\mu_\alpha, \sigma_\alpha) \\ 
\mu_\alpha &\sim N(0, 1) \\ 
\sigma_\alpha &\sim \text{Half-Cauchy}(0, 1)
\end{align*}$$

Formula and prior: 

```{r}
f <- bf(error_va ~ (1 | participantId), 
        sigma ~ (1|participantId) + offset(log(va.ans.x)))

p <- c(
  prior(normal(0, 1), class = Intercept),
  prior(cauchy(0, 1), class = sd, group = participantId, lb = 0),
  prior(normal(0, 1), class = Intercept, dpar = "sigma"), 
  prior(cauchy(0, 1), class = sd, group = participantId, dpar = sigma, lb = 0)
)
```

```{r}
#| eval: false 
#| echo: false 

task3_df %>% mutate(error_va = va.select.y - va.ans.y, 
                    log.va.ans.x = log(va.ans.x)) %>%
get_prior(formula = f,
          data = .)

task3_df %>% mutate(error_va = va.select.y - va.ans.y, 
                    log.va.ans.x = log(va.ans.x)) %>%
make_stancode(formula = f,
              data = ., 
              prior = p)
```

Fit model: 

```{r}
#| output: false

m3 <- task3_df %>%
  mutate(error_va = va.select.y - va.ans.y, 
         log.va.ans.x = log(va.ans.x)) %>%
  # mutate(error_va = ifelse(abs(error_va) < tolerance, 0, error_va)) %>%
  brm(
    formula = f,
    data = .,
    family = gaussian(),
    prior = p,
    chains = 4,
    file="models/task3",
    save_pars = save_pars(all=TRUE), 
    control = list(adapt_delta = 0.99), 
    iter = 6000
)
```

Check fit and posterior: 

```{r}
summary(m3)
plot(m3)
pp_check(m3, ndraws = 100)
```

Average participant behavior: 

```{r}
# m3 %>% get_variables(.)

# Extract posterior samples using spread_draws
m3 %>% spread_draws(b_sigma_Intercept) %>% 
  mutate(b_sigma = exp(b_sigma_Intercept)) %>% 
  ggplot(aes(x = b_sigma)) + 
  stat_halfeye()
```

Let's plot the ribbon plots, but first, let's see the difference between `add_predicted_draws` and `add_epred_draws`: 

```{r}
task3_df %>%
  mutate(error_va = va.select.y - va.ans.y) %>% 
  data_grid(va.ans.x = seq_range(va.ans.x, n = 100), 
            participantId = participantId) %>% 
  add_predicted_draws(m3, ndraws = 100) %>% 
  ggplot(aes(x = va.ans.x, y = .prediction)) + 
  stat_lineribbon(
    .width = c(.95, .80, .50),
    alpha = 0.5, 
    size = 0.5
  ) + scale_fill_brewer(palette = "Blues")

task3_df %>%
  mutate(error_va = va.select.y - va.ans.y) %>% 
  data_grid(va.ans.x = seq_range(va.ans.x, n = 100)) %>% 
  add_predicted_draws(m3, re_formula = NA, ndraws = 100) %>% 
  ggplot(aes(x = va.ans.x, y = .prediction)) + 
  stat_lineribbon(
    .width = c(.95, .80, .50),
    alpha = 0.5,
    size = 0.5
  ) + scale_fill_brewer(palette = "Blues")

task3_df %>%
  mutate(error_va = va.select.y - va.ans.y) %>% 
  # group_by(participantId) %>%
  data_grid(va.ans.x = seq_range(va.ans.x, n = 100)) %>%
  add_epred_draws(m3, re_formula = NA, ndraws = 100) %>% 
  ggplot(aes(x = va.ans.x, y = .epred)) + 
  stat_lineribbon(
    .width = c(.95, .80, .50),
    alpha = 0.5, 
    size = 0.5
  ) + scale_fill_brewer(palette = "Blues") 
# this is flat becasue this is just bar(mu)
```



```{r}
# task3_df %>% add_epred_draws(m3) %>% 
#   ggplot(aes(x = .epred)) + stat_halfeye()

task3_df %>%
  mutate(error_va = va.select.y - va.ans.y) %>% 
  data_grid(va.ans.x = seq_range(va.ans.x, n = 100), 
            participantId = participantId) %>% 
  add_predicted_draws(m3, ndraws = 100) %>% 
  ggplot(aes(x = va.ans.x, y = .prediction)) + 
  stat_lineribbon(
    .width = c(.95, .80, .50),
    alpha = 0.5, 
    size = 0.5
  ) + scale_fill_brewer(palette = "Blues") + 
  geom_point(data = task3_df, 
             aes(y = va.ans.y - va.select.y, x = va.ans.x), 
             alpha = 0.8, 
             size = 0.5) +
  labs(title = "Task 3 (re_formula = NULL)", y = "Signed error", x = "Distance to Y-Axis") -> p3

p3

task3_df %>%
  mutate(error_va = va.select.y - va.ans.y) %>% 
  data_grid(va.ans.x = seq_range(va.ans.x, n = 100)) %>% 
  add_predicted_draws(m3, re_formula = NA, ndraws = 100) %>% 
  ggplot(aes(x = va.ans.x, y = .prediction)) + 
  stat_lineribbon(
    .width = c(.95, .80, .50),
    alpha = 0.5,
    size = 0.5
  ) + scale_fill_brewer(palette = "Blues") + 
  geom_point(data = task3_df, 
             aes(y = va.ans.y - va.select.y, x = va.ans.x), 
             alpha = 0.8, 
             size = 0.5) +
  labs(title = "Task 3 (re_formula = NA)", y = "Signed error", x = "Distance to Y-Axis") -> p4

p4
```

```{r}
#| echo: false 
#| eval: false 

ggsave("plots/t3.1.pdf", plot = p3, height = 5, width = 10, units = "cm")
ggsave("plots/t3.2.pdf", plot = p4, height = 5, width = 10, units = "cm")
```

```{r}
#| echo: false 
#| eval: false 
(p1 + guides(color = "none", fill = "none", size = "none")) / (p2 + guides(color = "none", fill = "none", size = "none")) / (p3 + guides(color = "none", fill = "none", size = "none")) -> combined 
ggsave("plots/t3t5-combined.svg", plot = combined, height = 10, width = 10, units = "cm")
ggsave("plots/t3t5-combined.pdf", plot = combined, height = 9, width = 10, units = "cm")
```

