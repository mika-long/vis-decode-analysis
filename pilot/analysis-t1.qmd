---
title: "Analysis - Task 1"
format: 
  html: 
    code-fold: false
    reference-location: margin
    df-print: paged
    toc: true
    code-overflow: wrap
---

```{r}
#| echo: false
#| output: false
#| label: setup

library(tidyverse)
library(ggplot2)
library(sgt)
library(numDeriv)
library(ggdist)
# setting the theme 
theme_set(theme_minimal())
# model
library(brms)
# plot results 
library(tidybayes)
```

# Set up

Read in data 

```{r}
#| label: read-in-data
#| code-fold: true

df1 <- read.csv("pilot-01.csv") %>% as_tibble(.)

df <- read.csv("pilot-02.csv") %>% as_tibble(.) %>% 
  bind_rows(df1)

exclude_participants <- c("67fd4f955123c6d79ae66a3a", "67eedf7be13ffb77c677d4dd", "6443ebb84fc33e703937a6f9")

task_df <- df %>% filter(status == "completed") %>% 
  select(participantId, trialId, responseId, answer) %>%
  filter(str_detect(trialId, "task")) %>%
  mutate(answer = as.numeric(answer)) %>% 
  pivot_wider(names_from = responseId, values_from = answer, names_repair = "universal") %>% 
  separate_wider_delim(trialId, delim = "_", names = c("task", "type", "id")) %>% 
  filter(type != "train") %>% 
  select(-type) %>% 
  rename(data.select.x = location.x, 
         data.select.y = location.y,
         pixel.select.x = pixel.x, 
         pixel.select.y = pixel.y) %>% 
  filter(!participantId %in% exclude_participants)
```

```{r}
#| label: define-function
#| code-fold: true

# origin is top left  
data_to_pixel_y <- function(data_y) {
  return(-395 * data_y + 410)
}
data_to_pixel_x <- function(data_x) {
  return (53.5 * data_x + 317.5)
}

# origin is bottom left 
pixel_to_phy_x <- function(pixel, pxMM){
  (pixel - 50) / pxMM
}
pixel_to_phy_y <- function(pixel, pxMM){
  (410 - pixel) / pxMM
}

# return visual angle in degrees and not radian
vis_angle <- function(size, distance){
  return(2 * atan(size / (2 * distance)) * 180 / pi)
}

# tolerance for numerical precision 
tolerance <- 1e-10
```

```{r}
#| label: define-special-dfs
#| code-fold: true

p <- df %>% filter(status == "completed") %>% 
  select(participantId, trialId, responseId, answer) %>% 
  filter(grepl("calibration", trialId))

p %>% filter(responseId == "ball-positions") %>% 
  select(participantId, answer) %>% 
  mutate(answer = gsub("\\[|\\]", "", answer)) %>% 
  mutate(split_answer = str_split(answer, ",")) %>% 
  mutate(numeric_vectors = map(split_answer, ~ as.numeric(.x))) %>% 
  unnest(split_answer) %>% 
  mutate(split_answer = as.numeric(split_answer)) %>% 
  group_by(participantId) %>% 
  summarise(avg.ball.pos = sum(split_answer) / 5, 
            min.ball.pos = min(split_answer),
            max.ball.pos = max(split_answer)) -> avg_ball_pos

avg_ball_pos %>% mutate(true_ball_pos = (avg.ball.pos * 5 - min.ball.pos - max.ball.pos)/3) %>% 
  select(participantId, true_ball_pos) -> true_ball_pos

participants <- p %>% filter(grepl("pixelsPerMM|dist-calibration-MM", responseId)) %>%
  select(-trialId) %>%
  mutate(answer = as.numeric(answer)) %>%
  pivot_wider(names_from = responseId, values_from = answer) %>%
  rename(pixelToMM = pixelsPerMM, dist_to_screen = `dist-calibration-MM`) %>%
  filter(!participantId %in% exclude_participants) %>%
  left_join(avg_ball_pos) %>% 
  mutate(phy = dist_to_screen * tan(13.5 * pi / 180), 
         px = phy * pixelToMM, 
         square_pos = round(px + avg.ball.pos))

participants %>% left_join(true_ball_pos) %>% 
  mutate(ball.square.dist = (square_pos - true_ball_pos) / pixelToMM, 
         d = ball.square.dist / tan(13.5 * pi / 180)) %>% 
  select(participantId, pixelToMM, d) %>% 
  rename(dist_to_screen = d) -> participants
```

# Task 1 

Load data: 

```{r}
#| code-fold: true 

task1_df <- task_df %>% filter(task == "task1") %>% # task_df
  select(-slider.x, -slider.y) %>% 
  left_join(participants, by = join_by(participantId)) %>% 
  mutate(data.select.left_area = psgt(data.select.x, param.mu, param.sigma, param.lambda, param.p, param.q, mean.cent = FALSE), 
         data.ans.x = qsgt(0.5, param.mu, param.sigma, param.lambda, param.p, param.q, mean.cent = FALSE)) %>% 
  # pixel related 
  mutate(pixel.med.x = data_to_pixel_x(data.ans.x), 
         pixel.mod.x = data_to_pixel_x(param.mu)) %>% 
  # phy related 
  mutate(phy.select.x = pixel_to_phy_x(pixel.select.x, pixelToMM), 
         phy.med.x = pixel_to_phy_x(pixel.med.x, pixelToMM), 
         phy.mod.x = pixel_to_phy_x(pixel.mod.x, pixelToMM)) %>% 
  # visual angle related 
  mutate(va.select.x = vis_angle(phy.select.x, dist_to_screen), 
         va.med.x = vis_angle(phy.med.x, dist_to_screen), 
         va.mod.x = vis_angle(phy.mod.x, dist_to_screen))
```


```{r}
#| eval: false 
model <- cmdstan_model("stan_files/task1.hierarchical.stan")
model
``` 

Prepare data for stan: 

```{r}
#| eval: false 
N <- task1_df %>% nrow(.)
x <- task1_df %>% pull(va.select.x)
x_med <- task1_df %>% pull(va.med.x)
x_mod <- task1_df %>% pull(va.mod.x)

stan_data <- list(
  N = N, 
  x = x, 
  x_med = x_med, 
  x_mod = x_mod
)
```

Fit the stan model: 

```{r}
#| output: false 
#| eval: false 

fit <- model$sample(
  data = stan_data, 
  chains = 4, 
  # parallel_chains = 4
)
```