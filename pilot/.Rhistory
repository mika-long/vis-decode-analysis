pixel.select.y = data_to_pixel_y(data.select.y),
phy.select.x = pixel_to_phy_x(pixel.select.x, pixelToMM),
phy.select.y = pixel_to_phy_y(pixel.select.y, pixelToMM),
va.select.x = vis_angle(phy.select.x, dist_to_screen),
va.select.y = vis_angle(phy.select.y, dist_to_screen)) %>%
mutate(data.ans.y = 0.5,
data.ans.x = qsgt(0.5, param.mu, param.sigma, param.lambda, param.p, param.q, mean.cent = FALSE)) %>%
# do all the calculations for the actual answer
mutate(pixel.ans.x = data_to_pixel_x(data.ans.x),
pixel.ans.y = data_to_pixel_y(data.ans.y),
phy.ans.x = pixel_to_phy_x(pixel.ans.x, pixelToMM),
phy.ans.y = pixel_to_phy_y(pixel.ans.y, pixelToMM),
va.ans.x = vis_angle(phy.ans.x, dist_to_screen),
va.ans.y = vis_angle(phy.ans.y, dist_to_screen))
f <- bf(error_va ~ (1 | participantId),
sigma ~ (1|participantId) + offset(log(va.ans.x)))
p <- c(
prior(normal(0, 1), class = Intercept),
prior(cauchy(0, 1), class = sd, group = participantId, lb = 0),
prior(normal(0, 1), class = Intercept, dpar = "sigma"),
prior(cauchy(0, 1), class = sd, group = participantId, dpar = sigma, lb = 0)
)
#| output: false
#| label: task 3 fit normal
m3 <- task3_df %>%
mutate(error_va = va.select.y - va.ans.y,
log.va.ans.x = log(va.ans.x)) %>%
# mutate(error_va = ifelse(abs(error_va) < tolerance, 0, error_va)) %>%
brm(
formula = f,
data = .,
family = gaussian(),
prior = p,
chains = 4,
file="models/task3",
save_pars = save_pars(all=TRUE),
control = list(adapt_delta = 0.99),
iter = 6000
)
f <- bf(error_va ~ (1 | participantId),
sigma ~ (1|participantId) + offset(log(va.ans.x)))
p <- c(
prior(normal(0, 1), class = Intercept),
prior(normal(0, 1), class = sd, group = participantId, lb = 0),
prior(normal(0, 1), class = Intercept, dpar = "sigma"),
prior(normal(0, 1), class = sd, group = participantId, dpar = sigma, lb = 0)
)
#| output: false
#| label: task 3 fit normal
m3 <- task3_df %>%
mutate(error_va = va.select.y - va.ans.y,
log.va.ans.x = log(va.ans.x)) %>%
# mutate(error_va = ifelse(abs(error_va) < tolerance, 0, error_va)) %>%
brm(
formula = f,
data = .,
family = gaussian(),
prior = p,
chains = 4,
file="models/task3",
save_pars = save_pars(all=TRUE),
control = list(adapt_delta = 0.99),
iter = 6000
)
summary(m3)
plot(m3)
pp_check(m3, ndraws = 100)
pp_check(m3, ndraws = 100, type = "pit_ecdf")
task3_df %>%
mutate(error_va = va.select.y - va.ans.y) %>%
data_grid(va.ans.x = seq_range(va.ans.x, n = 100)) %>%
add_predicted_draws(m3, re_formula = NA) %>% # don't need the ndraws = 100 unless we're doing spaghetti plots
ggplot(aes(x = va.ans.x, y = .prediction)) +
stat_lineribbon(
.width = c(.95, .80, .50),
# alpha = 0.5,
size = 0.5,
) + scale_fill_brewer(palette = "Blues") +
geom_point(data = task3_df,
aes(y = va.ans.y - va.select.y, x = va.ans.x),
alpha = 0.8,
size = 0.5) +
labs(y = "Signed error", x = "Distance to Y-Axis") +
theme_minimal(
base_size = 8) +
theme(legend.position="none")-> p4
task3_df %>%
mutate(error_va = va.select.y - va.ans.y) %>%
data_grid(va.ans.x = seq_range(va.ans.x, n = 100)) %>%
add_predicted_draws(m3, re_formula = NA) %>% # don't need the ndraws = 100 unless we're doing spaghetti plots
ggplot(aes(x = va.ans.x, y = .prediction)) +
stat_lineribbon(
.width = c(.95, .80, .50),
# alpha = 0.5,
size = 0.5,
) + scale_fill_brewer(palette = "Blues") +
geom_point(data = task3_df,
aes(y = va.ans.y - va.select.y, x = va.ans.x),
alpha = 0.8,
size = 0.5) +
labs(y = "Signed error", x = "Distance to Y-Axis") +
theme_minimal(
base_size = 8) +
theme(legend.position="none")-> p4
p4
ggsave("plots/task3.pdf", plot = p4, height = 5, width = 5, units = "cm")
#| label: task 5 load data
#| code-fold: true
task5_df <- task_df %>% filter(task == "task5") %>% # or use task_df for full
select(participantId, task, id, data.select.x, data.select.y, slider.x, slider.y) %>%
rename(data.ans.x = data.select.x,
data.ans.y = data.select.y,
data.select.x = slider.x,
data.select.y = slider.y) %>%
left_join(participants, by = join_by(participantId)) %>%
# do all the calculations for user's selected
mutate(pixel.select.x = data_to_pixel_x(data.select.x),
pixel.select.y = data_to_pixel_y(data.select.y),
phy.select.x = pixel_to_phy_x(pixel.select.x, pixelToMM),
phy.select.y = pixel_to_phy_y(pixel.select.y, pixelToMM),
va.select.x = vis_angle(phy.select.x, dist_to_screen),
va.select.y = vis_angle(phy.select.y, dist_to_screen)) %>%
# do all the calculations for the actual answer
mutate(pixel.ans.x = data_to_pixel_x(data.ans.x),
pixel.ans.y = data_to_pixel_y(data.ans.y),
phy.ans.x = pixel_to_phy_x(pixel.ans.x, pixelToMM),
phy.ans.y = pixel_to_phy_y(pixel.ans.y, pixelToMM),
va.ans.x = vis_angle(phy.ans.x, dist_to_screen),
va.ans.y = vis_angle(phy.ans.y, dist_to_screen))
f <- bf(error_va ~ (1 | participantId),
sigma ~ (1 | participantId) + offset(log(va.ans.y)))
p <- c(
prior(normal(0, 1), class = Intercept),
prior(cauchy(0, 1), class = sd, group = participantId, lb = 0),
prior(normal(0, 1), class = Intercept, dpar = "sigma"),
prior(cauchy(0, 1), class = sd, group = participantId, dpar = sigma, lb = 0)
)
#| echo: false
#| output: false
#| eval: false
task5_df %>% mutate(error_va = va.select.x - va.ans.x) %>%
get_prior(formula = f,
data = .)
task5_df %>% mutate(error_va = va.select.x - va.ans.x) %>%
make_stancode(f, data = ., prior = p, family = gaussian())
task5_df %>% mutate(error_va = va.select.x - va.ans.x) %>%
make_standata(f, data = ., prior = p, family = gaussian())
#| output: false
m.5.x.va <- task5_df %>% mutate(error_va = va.select.x - va.ans.x) %>%
# account for numerical precision
# mutate(error_va = ifelse(abs(error_va) < tolerance, 0, error_va)) %>%
brm(
formula = f,
data = .,
family = gaussian(),
prior = p,
chains = 4,
# cores = 4,
control = list(adapt_delta = 0.99),
iter = 6000,
file = "models/task5.x",
save_pars = save_pars(all = TRUE)
)
f <- bf(error_va ~ (1 | participantId),
sigma ~ (1 | participantId) + offset(log(va.ans.y)))
p <- c(
prior(normal(0, 1), class = Intercept),
prior(normal(0, 1), class = sd, group = participantId, lb = 0),
prior(normal(0, 1), class = Intercept, dpar = "sigma"),
prior(normal(0, 1), class = sd, group = participantId, dpar = sigma, lb = 0)
)
#| output: false
m.5.x.va <- task5_df %>% mutate(error_va = va.select.x - va.ans.x) %>%
# account for numerical precision
# mutate(error_va = ifelse(abs(error_va) < tolerance, 0, error_va)) %>%
brm(
formula = f,
data = .,
family = gaussian(),
prior = p,
chains = 4,
# cores = 4,
control = list(adapt_delta = 0.99),
iter = 6000,
file = "models/task5.x",
save_pars = save_pars(all = TRUE)
)
summary(m.5.x.va)
plot(m.5.x.va)
pp_check(m.5.x.va, ndraws = 100)
pp_check(m.5.x.va, ndraws = 100, type = "pit_ecdf")
prediction_grid <- task5_df %>% data_grid(va.ans.y = seq_range(va.ans.y, n = 50)) %>%
add_predicted_draws(m.5.x.va, re_formula = NA)
ggplot(prediction_grid, aes(x = va.ans.y, y = .prediction)) +
stat_lineribbon(
.width = c(.95, .80, .50),
alpha = 0.5,
size = 0.5
) + scale_fill_brewer(palette = "Blues") +
geom_point(data = task5_df, aes(y = va.select.x - va.ans.x, x = va.ans.y), alpha = 0.8, size = 0.5) +
labs(title = "Task 5 (Project to X)", y = "Signed Error", x = "Distance to X-Axis") +
theme_minimal(base_size = 8) +
theme(legend.position = "none") -> p1 # +
p1
f <- bf(error_va ~ (1 | participantId),
sigma ~ (1|participantId) + offset(log(va.ans.x)))
p <- c(
prior(normal(0, 1), class = Intercept),
prior(normal(0, 1), class = sd, group = participantId, lb = 0),
prior(normal(0, 1), class = Intercept, dpar = "sigma"),
prior(normal(0, 1), class = sd, group = participantId, dpar = sigma, lb = 0)
)
#| output: false
m.5.y.va <- task5_df %>% mutate(error_va = va.select.y - va.ans.y) %>%
# account for numerical precision
# mutate(error_va = ifelse(abs(error_va) < tolerance, 0, error_va)) %>%
brm(
formula = f,
data = .,
family = gaussian(),
prior = p,
chains = 4,
# cores = 4,
control = list(adapt_delta = 0.99),
iter = 6000,
file = "models/task5.y",
save_pars = save_pars(all = TRUE)
)
summary(m.5.y.va)
plot(m.5.y.va)
pp_check(m.5.y.va, ndraws = 100)
pp_check(m.5.y.va, ndraws = 100, type = "pit_ecdf")
prediction_grid <- task5_df %>% data_grid(va.ans.x = seq_range(va.ans.x, n = 50)) %>%
add_predicted_draws(m.5.y.va, re_formula = NA)
ggplot(prediction_grid, aes(x = va.ans.x, y = .prediction)) +
stat_lineribbon(
.width = c(.95, .80, .50),
alpha = 0.5,
size = 0.5
) +
scale_fill_brewer(palette = "Blues")  +
geom_point(data = task5_df,
aes(y = va.select.y - va.ans.y, x = va.ans.x),
alpha = 0.8,
size = 0.5) +
# ylim(-0.5, 0.5) +
labs(title = "Task 5 (Project to Y)", y = "Signed Error", x = "Distance to Y-Axis") +
theme_minimal(base_size = 8) +
theme(legend.position = "none") -> p2 # +
p2
p1 + p2 -> combined
combined
ggsave("plots/task5-combined.pdf", combined, height = 3.5, width = 10, units = "cm")
#| echo: false
#| output: false
#| label: setup
library(tidyverse)
library(ggplot2)
library(sgt)
library(numDeriv)
library(ggdist)
# setting the theme
theme_set(theme_minimal())
# model
library(brms)
# plot results
library(tidybayes)
library(cmdstanr)
library(posterior)
#| label: define-function
#| code-fold: true
# origin is top left
data_to_pixel_y <- function(data_y) {
return(-395 * data_y + 410)
}
data_to_pixel_x <- function(data_x) {
return (53.5 * data_x + 317.5)
}
# origin is bottom left
pixel_to_phy_x <- function(pixel, pxMM){
(pixel - 50) / pxMM
}
pixel_to_phy_y <- function(pixel, pxMM){
(410 - pixel) / pxMM
}
# return visual angle in degrees and not radian
vis_angle <- function(size, distance){
return(2 * atan(size / (2 * distance)) * 180 / pi)
}
# tolerance for numerical precision
tolerance <- 1e-10
#| code-fold: true
task1_df <- task_df %>% filter(task == "task1") %>% # task_df
select(-slider.x, -slider.y) %>%
right_join(participants, by = join_by(participantId)) %>%
mutate(data.select.left_area = psgt(data.select.x, param.mu, param.sigma, param.lambda, param.p, param.q, mean.cent = FALSE),
data.ans.x = qsgt(0.5, param.mu, param.sigma, param.lambda, param.p, param.q, mean.cent = FALSE)) %>%
# pixel related
mutate(pixel.med.x = data_to_pixel_x(data.ans.x),
pixel.mod.x = data_to_pixel_x(param.mu)) %>%
# phy related
mutate(phy.select.x = pixel_to_phy_x(pixel.select.x, pixelToMM),
phy.med.x = pixel_to_phy_x(pixel.med.x, pixelToMM),
phy.mod.x = pixel_to_phy_x(pixel.mod.x, pixelToMM)) %>%
# visual angle related
mutate(va.select.x = vis_angle(phy.select.x, dist_to_screen),
va.med.x = vis_angle(phy.med.x, dist_to_screen),
va.mod.x = vis_angle(phy.mod.x, dist_to_screen))
N <- task1_df %>% nrow(.)
J <- length(unique(task1_df$participantId))
x <- task1_df %>% pull(va.select.x)
x_med <- task1_df %>% pull(va.med.x)
x_mod <- task1_df %>% pull(va.mod.x)
# change the participantId to numeric id
# 1. Get unique participant IDs
unique_ids <- unique(task1_df$participantId)
# 2. Create a mapping
id_mapping <- setNames(1:length(unique_ids), unique_ids)
# 3. Create the numeric ID vector
numeric_id <- as.numeric(factor(task1_df$participantId, levels = names(id_mapping)))
stan_data <- list(
N = N,
J = J,
id = numeric_id,
x = x,
x_med = x_med,
x_mod = x_mod
)
#| label: custom pp_check
custom_pp_check <- function(
fitted_model,
fun = bayesplot::ppc_dens_overlay,
ndraws = 100,
transform = identity,
...
) {
y_rep <- as_draws_rvars(fitted_model)$y_rep |>
transform() |>
as_draws_matrix()
if (!is.null(ndraws)) {
y_rep = y_rep |>
merge_chains() |>
resample_draws(ndraws = ndraws)
}
y <- fitted_model$draws("x_org", format = "matrix")[1, ] |>
as.vector() |>
transform()
fun(y, y_rep, ...)
}
model <- cmdstan_model("stan_files/task1.weighted.avg.nonc.stan")
fit <- read_rds("models/task1.informative.prior.rds")
custom_pp_check(fit, bayesplot::ppc_dens_overlay_grouped, group = ifelse(task1_df$param.lambda < 0, "neg", ifelse(task1_df$param.lambda > 0, "pos", "zero")))
# param.lambda on x-axis
task1_df %>% mutate(y_rep = as_draws_rvars(fit)$y_rep - va.med.x) %>% # signed error
unnest_rvars() %>%
ggplot(aes(x = param.lambda, y = y_rep)) +
ggdist::stat_lineribbon() +
geom_point(aes(y = va.select.x - va.med.x))
fit
model <- read_rds("models/task1.informative.prior.rds")
fit <- model$summary()
fit
custom_pp_check(fit, bayesplot::ppc_dens_overlay_grouped, group = ifelse(task1_df$param.lambda < 0, "neg", ifelse(task1_df$param.lambda > 0, "pos", "zero")))
fit
fit <- read_rds("models/task1.informative.prior.rds")
# we recommend running this in a fresh R session or restarting your current session
install.packages("cmdstanr", repos = c('https://stan-dev.r-universe.dev', getOption("repos")))
install.packages("cmdstanr", repos = c("https://stan-dev.r-universe.dev", getOption("repos")))
#| echo: false
#| output: false
#| label: setup
library(tidyverse)
library(ggplot2)
library(sgt)
library(numDeriv)
library(ggdist)
# setting the theme
theme_set(theme_minimal(base_size = 8))
# model
library(brms)
# plot results
library(tidybayes)
library(cmdstanr)
library(posterior)
#| label: read-in-data
#| code-fold: true
task_df <- read_rds("task.rds")
participants <- read_rds("participants.rds")
#| label: define-function
#| code-fold: true
# origin is top left
data_to_pixel_y <- function(data_y) {
return(-395 * data_y + 410)
}
data_to_pixel_x <- function(data_x) {
return (53.5 * data_x + 317.5)
}
# origin is bottom left
pixel_to_phy_x <- function(pixel, pxMM){
(pixel - 50) / pxMM
}
pixel_to_phy_y <- function(pixel, pxMM){
(410 - pixel) / pxMM
}
# return visual angle in degrees and not radian
vis_angle <- function(size, distance){
return(2 * atan(size / (2 * distance)) * 180 / pi)
}
# tolerance for numerical precision
tolerance <- 1e-10
#| code-fold: true
task1_df <- task_df %>% filter(task == "task1") %>% # task_df
select(-slider.x, -slider.y) %>%
right_join(participants, by = join_by(participantId)) %>%
mutate(data.select.left_area = psgt(data.select.x, param.mu, param.sigma, param.lambda, param.p, param.q, mean.cent = FALSE),
data.ans.x = qsgt(0.5, param.mu, param.sigma, param.lambda, param.p, param.q, mean.cent = FALSE)) %>%
# pixel related
mutate(pixel.med.x = data_to_pixel_x(data.ans.x),
pixel.mod.x = data_to_pixel_x(param.mu)) %>%
# phy related
mutate(phy.select.x = pixel_to_phy_x(pixel.select.x, pixelToMM),
phy.med.x = pixel_to_phy_x(pixel.med.x, pixelToMM),
phy.mod.x = pixel_to_phy_x(pixel.mod.x, pixelToMM)) %>%
# visual angle related
mutate(va.select.x = vis_angle(phy.select.x, dist_to_screen),
va.med.x = vis_angle(phy.med.x, dist_to_screen),
va.mod.x = vis_angle(phy.mod.x, dist_to_screen))
N <- task1_df %>% nrow(.)
J <- length(unique(task1_df$participantId))
x <- task1_df %>% pull(va.select.x)
x_med <- task1_df %>% pull(va.med.x)
x_mod <- task1_df %>% pull(va.mod.x)
# change the participantId to numeric id
# 1. Get unique participant IDs
unique_ids <- unique(task1_df$participantId)
# 2. Create a mapping
id_mapping <- setNames(1:length(unique_ids), unique_ids)
# 3. Create the numeric ID vector
numeric_id <- as.numeric(factor(task1_df$participantId, levels = names(id_mapping)))
stan_data <- list(
N = N,
J = J,
id = numeric_id,
x = x,
x_med = x_med,
x_mod = x_mod
)
#| label: custom pp_check
custom_pp_check <- function(
fitted_model,
fun = bayesplot::ppc_dens_overlay,
ndraws = 100,
transform = identity,
...
) {
y_rep <- as_draws_rvars(fitted_model)$y_rep |>
transform() |>
as_draws_matrix()
if (!is.null(ndraws)) {
y_rep = y_rep |>
merge_chains() |>
resample_draws(ndraws = ndraws)
}
y <- fitted_model$draws("x_org", format = "matrix")[1, ] |>
as.vector() |>
transform()
fun(y, y_rep, ...)
}
fit <- read_rds("models/task1.informative.prior.rds")
custom_pp_check(fit, bayesplot::ppc_dens_overlay_grouped, group = ifelse(task1_df$param.lambda < 0, "neg", ifelse(task1_df$param.lambda > 0, "pos", "zero")))
custom_pp_check(fit, bayesplot::ppc_pit_ecdf, transform = \(x) x - task1_df$va.med.x, ndraws = NULL)
custom_pp_check(fit, bayesplot::ppc_pit_ecdf_grouped, group = ifelse(task1_df$param.lambda < 0, "neg", ifelse(task1_df$param.lambda > 0, "pos", "zero")))
fit$draws()
fit$draws(format = "df")
draws_df <- fit$draws(format = "df")
draws_df
task1_df
min(task1_df$va.med.x)
expand_grid(participantId = task1_df$participantId, va.med.x = seq(min(task1_df$va.med.x, max(task1_df$va.med.x, 0.1))))
min(task1_df$va.med.x, max(task1_df$va.med.x, 0.1)
expand_grid(participantId = task1_df$participantId, va.med.x = seq(min(task1_df$va.med.x, max(task1_df$va.med.x), 0.1)))
expand_grid(participantId = task1_df$participantId,
va.med.x = seq(min(task1_df$va.med.x), max(task1_df$va.med.x), 0.1))
seq(min(task1_df$va.med.x), max(task1_df$va.med.x), 0.1)
expand_grid(participantId = task1_df$participantId,
va.med.x = seq(min(task1_df$va.med.x), max(task1_df$va.med.x), 0.1)) %>%
add_predicted_draws(., draws_df)
expand_grid(participantId = task1_df$participantId,
va.med.x = seq(min(task1_df$va.med.x), max(task1_df$va.med.x), 0.1)) %>%
add_predicted_draws(., fit)
fit
type(fit)
typeof(fit)
expand_grid(participantId = task1_df$participantId,
va.med.x = seq(min(task1_df$va.med.x), max(task1_df$va.med.x), 0.1)) # %>%
posterior_predict(fit)
fit$summary)_
fit$summary()
fit <- read_rds("models/task1.informative.prior.rds")
typeof(fit)
class(fit)
draws_df <- fit$draws(format = "df")
class(draws_df)
library(posterior)
class(draws_df)
fit$summary() %>% class(.)
draws_df %>% as_draws()
draws_df %>% as_draws(.)
draws_df <- fit$draws(format = "df") %>% as_draws(.)
draws_df
draws_df %>% class(.)
as_draws_df(fit$draws())
