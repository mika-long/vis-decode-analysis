---
title: "Descriptive Checks"
format:
  html: 
    code-fold: false
    reference-location: margin
    df-print: paged
    toc: true
    code-overflow: wrap
---

```{r}
#| echo: false
#| output: false
#| label: setup

library(tidyverse)
library(ggplot2)
library(sgt)
library(numDeriv)
library(ggdist)
# setting the theme 
theme_set(theme_minimal())
# model
library(brms)
# plot results 
library(tidybayes)
```

# Set up 

read in data and write functions for processing: 

```{r}
#| label: read-in-data
#| code-fold: true

df <- read.csv("pilot-01.csv") %>% as_tibble(.)

task_df <- df %>% select(participantId, trialId, responseId, answer) %>%
  filter(str_detect(trialId, "task")) %>%
  mutate(answer = as.numeric(answer)) %>% 
  pivot_wider(names_from = responseId, values_from = answer, names_repair = "universal") %>% 
  separate_wider_delim(trialId, delim = "_", names = c("task", "type", "id")) %>% 
  select(-type) %>% 
  rename(data.select.x = location.x, 
         data.select.y = location.y,
         pixel.select.x = pixel.x, 
         pixel.select.y = pixel.y)
```

```{r}
#| label: define-function
#| code-fold: true

# origin is top left  
data_to_pixel_y <- function(data_y) {
  return(-395 * data_y + 410)
}
data_to_pixel_x <- function(data_x) {
  return (53.5 * data_x + 317.5)
}

# origin is bottom left 
pixel_to_phy_x <- function(pixel, pxMM){
  (pixel - 50) / pxMM
}
pixel_to_phy_y <- function(pixel, pxMM){
  (410 - pixel) / pxMM
}

# return visual angle in degrees and not radian
vis_angle <- function(size, distance){
  return(2 * atan(size / (2 * distance)) * 180 / pi)
}

# tolerance for numerical precision 
tolerance <- 1e-10
```

TODO --- things from here could be changed for the purpose of the actual collected data 

```{r}
#| label: define-special-dfs
#| code-fold: true

p <- df %>% select(participantId, trialId, responseId, answer) %>% 
  filter(grepl("calibration", trialId))

# potential todo: we might want to change things ... with how the distance is calculated ... 

demographics <- df %>% select(participantId, trialId, responseId, answer) %>% 
  filter(grepl("gender|age|feedback|strategy", responseId))

participants <- p %>% filter(grepl("pixelsPerMM|dist-calibration-MM", responseId)) %>% 
  select(-trialId) %>% 
  mutate(answer = as.numeric(answer)) %>% 
  pivot_wider(names_from = responseId, values_from = answer) %>% 
  rename(pixelToMM = pixelsPerMM, dist_to_screen = `dist-calibration-MM`)
```


# Task 1 -- Split area into equal halves

Load data: 

```{r}
#| label: get task 1 data 
#| code-fold: true 

task1_df <- task_df %>% filter(task == "task1") %>% 
  select(-slider.x, -slider.y) %>% 
  mutate(data.select.left_area = psgt(data.select.x, param.mu, param.sigma, param.lambda, param.p, param.q, mean.cent = FALSE), 
         data.ans.x = qsgt(0.5, param.mu, param.sigma, param.lambda, param.p, param.q, mean.cent = FALSE)) %>% 
  left_join(participants, by = join_by(participantId))
```

Plotting selection, answer, and `x` coordinate for highest point against lambda: 

```{r}
task1_df %>% ggplot(aes(y = data.select.x - data.ans.x, x = param.lambda)) + 
  geom_point(alpha = 0.5) # + 
  geom_point(aes(y = data.ans.x - param.mu, x = param.lambda), color = "red", alpha = 0.5)
  
task1_df %>% ggplot(aes(y = data.select.left_area - 0.5, x = param.lambda)) + 
geom_point(alpha = 0.5)
```

As can be seen here, there is a clear difference in trend ... As skewness $\lambda$ changes, the difference between the median `data.ans.x` and the mode `param.mu` increases. This provides some evidence that we're not purely using the highest point as a proxy. 

Plotting left area, answer, as well as `answer^0.7`: 

```{r}
task1_df %>% ggplot(aes(x = param.lambda, y = data.select.left_area)) + 
  geom_point(alpha = 0.5) + 
  geom_hline(yintercept = 0.5, linetype="dashed", color = "gray") + 
  geom_hline(yintercept = 0.5^0.7, linetype = "dashed", color = "darkgray") + 
  ylim(0, 1)
```

Plotting other relations: 

```{r}
#| layout-ncol: 2
#| code-fold: true 


task1_df %>% ggplot(aes(x = param.lambda, y = data.select.x - param.mu)) + geom_point(alpha = 0.5)

task1_df %>% ggplot(aes(x =  data.select.x - param.mu)) + 
  geom_dots()

task1_df %>% ggplot(aes(y =  data.select.x - param.mu, x = dist_to_screen)) + 
  geom_point()

task1_df %>% ggplot(aes(y =  data.select.left_area - 0.5, x = dist_to_screen)) + 
  geom_point()

task1_df %>% ggplot(aes(x = data.ans.x - data.select.x)) + 
  geom_dots()

task1_df %>% ggplot(aes(y = data.ans.x - data.select.x, x = dist_to_screen)) + 
  geom_point()

task1_df %>% ggplot(aes(y = data.select.left_area^(1/0.7), x = param.lambda)) + 
  geom_point()
```

# Task 2 --- 

... 


# Task 3 --- 


# Task 4 --- 
... 

# Task 5 --- 

